<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>bin/node_modules/socket.io-client/socket.io.js - Prometheus Framework</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="Prometheus Framework"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Represents a 
                Replicaset Configuration.html">Represents a 
                Replicaset Configuration</a></li>
                                <li><a href="../classes/Represents a BatchWriteResult.html">Represents a BatchWriteResult</a></li>
                                <li><a href="../classes/Represents a Collection.html">Represents a Collection</a></li>
                                <li><a href="../classes/Represents a Cursor..html">Represents a Cursor.</a></li>
                                <li><a href="../classes/Represents a CursorStream..html">Represents a CursorStream.</a></li>
                                <li><a href="../classes/Represents a Db.html">Represents a Db</a></li>
                                <li><a href="../classes/Represents a GridFS File Stream..html">Represents a GridFS File Stream.</a></li>
                                <li><a href="../classes/.html"></a></li>
                                <li><a href="../classes/Represents a MongoClient.html">Represents a MongoClient</a></li>
                                <li><a href="../classes/Represents a Mongos connection with failover to backup proxies.html">Represents a Mongos connection with failover to backup proxies</a></li>
                                <li><a href="../classes/Represents a OrderedBulkOperation.html">Represents a OrderedBulkOperation</a></li>
                                <li><a href="../classes/Represents a Read Preference..html">Represents a Read Preference.</a></li>
                                <li><a href="../classes/Represents a Server connection..html">Represents a Server connection.</a></li>
                                <li><a href="../classes/Represents a UnorderedBulkOperation.html">Represents a UnorderedBulkOperation</a></li>
                                <li><a href="../classes/Represents the Admin methods of MongoDB..html">Represents the Admin methods of MongoDB.</a></li>
                                <li><a href="../classes/Represents the Grid..html">Represents the Grid.</a></li>
                                <li><a href="../classes/Represents the GridStore..html">Represents the GridStore.</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/association.html">association</a></li>
                                <li><a href="../modules/database-accessor.html">database-accessor</a></li>
                                <li><a href="../modules/field-type-manager.html">field-type-manager</a></li>
                                <li><a href="../modules/resource-type-manager.html">resource-type-manager</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: bin/node_modules/socket.io-client/socket.io.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        !function(e){if(&quot;object&quot;==typeof exports&amp;&amp;&quot;undefined&quot;!=typeof module)module.exports=e();else if(&quot;function&quot;==typeof define&amp;&amp;define.amd)define([],e);else{var f;&quot;undefined&quot;!=typeof window?f=window:&quot;undefined&quot;!=typeof global?f=global:&quot;undefined&quot;!=typeof self&amp;&amp;(f=self),f.io=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==&quot;function&quot;&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);throw new Error(&quot;Cannot find module &#x27;&quot;+o+&quot;&#x27;&quot;)}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==&quot;function&quot;&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
                        
                        module.exports = _dereq_(&#x27;./lib/&#x27;);
                        
                        },{&quot;./lib/&quot;:2}],2:[function(_dereq_,module,exports){
                        
                        /**
                         * Module dependencies.
                         */
                        
                        var url = _dereq_(&#x27;./url&#x27;);
                        var parser = _dereq_(&#x27;socket.io-parser&#x27;);
                        var Manager = _dereq_(&#x27;./manager&#x27;);
                        var debug = _dereq_(&#x27;debug&#x27;)(&#x27;socket.io-client&#x27;);
                        
                        /**
                         * Module exports.
                         */
                        
                        module.exports = exports = lookup;
                        
                        /**
                         * Managers cache.
                         */
                        
                        var cache = exports.managers = {};
                        
                        /**
                         * Looks up an existing &#x60;Manager&#x60; for multiplexing.
                         * If the user summons:
                         *
                         *   &#x60;io(&#x27;http://localhost/a&#x27;);&#x60;
                         *   &#x60;io(&#x27;http://localhost/b&#x27;);&#x60;
                         *
                         * We reuse the existing instance based on same scheme/port/host,
                         * and we initialize sockets for each namespace.
                         *
                         * @api public
                         */
                        
                        function lookup(uri, opts) {
                          if (typeof uri == &#x27;object&#x27;) {
                            opts = uri;
                            uri = undefined;
                          }
                        
                          opts = opts || {};
                        
                          var parsed = url(uri);
                          var source = parsed.source;
                          var id = parsed.id;
                          var io;
                        
                          if (opts.forceNew || opts[&#x27;force new connection&#x27;] || false === opts.multiplex) {
                            debug(&#x27;ignoring socket cache for %s&#x27;, source);
                            io = Manager(source, opts);
                          } else {
                            if (!cache[id]) {
                              debug(&#x27;new io instance for %s&#x27;, source);
                              cache[id] = Manager(source, opts);
                            }
                            io = cache[id];
                          }
                        
                          return io.socket(parsed.path);
                        }
                        
                        /**
                         * Protocol version.
                         *
                         * @api public
                         */
                        
                        exports.protocol = parser.protocol;
                        
                        /**
                         * &#x60;connect&#x60;.
                         *
                         * @param {String} uri
                         * @api public
                         */
                        
                        exports.connect = lookup;
                        
                        /**
                         * Expose constructors for standalone build.
                         *
                         * @api public
                         */
                        
                        exports.Manager = _dereq_(&#x27;./manager&#x27;);
                        exports.Socket = _dereq_(&#x27;./socket&#x27;);
                        
                        },{&quot;./manager&quot;:3,&quot;./socket&quot;:5,&quot;./url&quot;:6,&quot;debug&quot;:9,&quot;socket.io-parser&quot;:40}],3:[function(_dereq_,module,exports){
                        
                        /**
                         * Module dependencies.
                         */
                        
                        var url = _dereq_(&#x27;./url&#x27;);
                        var eio = _dereq_(&#x27;engine.io-client&#x27;);
                        var Socket = _dereq_(&#x27;./socket&#x27;);
                        var Emitter = _dereq_(&#x27;component-emitter&#x27;);
                        var parser = _dereq_(&#x27;socket.io-parser&#x27;);
                        var on = _dereq_(&#x27;./on&#x27;);
                        var bind = _dereq_(&#x27;component-bind&#x27;);
                        var object = _dereq_(&#x27;object-component&#x27;);
                        var debug = _dereq_(&#x27;debug&#x27;)(&#x27;socket.io-client:manager&#x27;);
                        var indexOf = _dereq_(&#x27;indexof&#x27;);
                        
                        /**
                         * Module exports
                         */
                        
                        module.exports = Manager;
                        
                        /**
                         * &#x60;Manager&#x60; constructor.
                         *
                         * @param {String} engine instance or engine uri/opts
                         * @param {Object} options
                         * @api public
                         */
                        
                        function Manager(uri, opts){
                          if (!(this instanceof Manager)) return new Manager(uri, opts);
                          if (uri &amp;&amp; (&#x27;object&#x27; == typeof uri)) {
                            opts = uri;
                            uri = undefined;
                          }
                          opts = opts || {};
                        
                          opts.path = opts.path || &#x27;/socket.io&#x27;;
                          this.nsps = {};
                          this.subs = [];
                          this.opts = opts;
                          this.reconnection(opts.reconnection !== false);
                          this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
                          this.reconnectionDelay(opts.reconnectionDelay || 1000);
                          this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
                          this.timeout(null == opts.timeout ? 20000 : opts.timeout);
                          this.readyState = &#x27;closed&#x27;;
                          this.uri = uri;
                          this.connected = [];
                          this.attempts = 0;
                          this.encoding = false;
                          this.packetBuffer = [];
                          this.encoder = new parser.Encoder();
                          this.decoder = new parser.Decoder();
                          this.autoConnect = opts.autoConnect !== false;
                          if (this.autoConnect) this.open();
                        }
                        
                        /**
                         * Propagate given event to sockets and emit on &#x60;this&#x60;
                         *
                         * @api private
                         */
                        
                        Manager.prototype.emitAll = function() {
                          this.emit.apply(this, arguments);
                          for (var nsp in this.nsps) {
                            this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
                          }
                        };
                        
                        /**
                         * Mix in &#x60;Emitter&#x60;.
                         */
                        
                        Emitter(Manager.prototype);
                        
                        /**
                         * Sets the &#x60;reconnection&#x60; config.
                         *
                         * @param {Boolean} true/false if it should automatically reconnect
                         * @return {Manager} self or value
                         * @api public
                         */
                        
                        Manager.prototype.reconnection = function(v){
                          if (!arguments.length) return this._reconnection;
                          this._reconnection = !!v;
                          return this;
                        };
                        
                        /**
                         * Sets the reconnection attempts config.
                         *
                         * @param {Number} max reconnection attempts before giving up
                         * @return {Manager} self or value
                         * @api public
                         */
                        
                        Manager.prototype.reconnectionAttempts = function(v){
                          if (!arguments.length) return this._reconnectionAttempts;
                          this._reconnectionAttempts = v;
                          return this;
                        };
                        
                        /**
                         * Sets the delay between reconnections.
                         *
                         * @param {Number} delay
                         * @return {Manager} self or value
                         * @api public
                         */
                        
                        Manager.prototype.reconnectionDelay = function(v){
                          if (!arguments.length) return this._reconnectionDelay;
                          this._reconnectionDelay = v;
                          return this;
                        };
                        
                        /**
                         * Sets the maximum delay between reconnections.
                         *
                         * @param {Number} delay
                         * @return {Manager} self or value
                         * @api public
                         */
                        
                        Manager.prototype.reconnectionDelayMax = function(v){
                          if (!arguments.length) return this._reconnectionDelayMax;
                          this._reconnectionDelayMax = v;
                          return this;
                        };
                        
                        /**
                         * Sets the connection timeout. &#x60;false&#x60; to disable
                         *
                         * @return {Manager} self or value
                         * @api public
                         */
                        
                        Manager.prototype.timeout = function(v){
                          if (!arguments.length) return this._timeout;
                          this._timeout = v;
                          return this;
                        };
                        
                        /**
                         * Starts trying to reconnect if reconnection is enabled and we have not
                         * started reconnecting yet
                         *
                         * @api private
                         */
                        
                        Manager.prototype.maybeReconnectOnOpen = function() {
                          // Only try to reconnect if it&#x27;s the first time we&#x27;re connecting
                          if (!this.openReconnect &amp;&amp; !this.reconnecting &amp;&amp; this._reconnection &amp;&amp; this.attempts === 0) {
                            // keeps reconnection from firing twice for the same reconnection loop
                            this.openReconnect = true;
                            this.reconnect();
                          }
                        };
                        
                        
                        /**
                         * Sets the current transport &#x60;socket&#x60;.
                         *
                         * @param {Function} optional, callback
                         * @return {Manager} self
                         * @api public
                         */
                        
                        Manager.prototype.open =
                        Manager.prototype.connect = function(fn){
                          debug(&#x27;readyState %s&#x27;, this.readyState);
                          if (~this.readyState.indexOf(&#x27;open&#x27;)) return this;
                        
                          debug(&#x27;opening %s&#x27;, this.uri);
                          this.engine = eio(this.uri, this.opts);
                          var socket = this.engine;
                          var self = this;
                          this.readyState = &#x27;opening&#x27;;
                          this.skipReconnect = false;
                        
                          // emit &#x60;open&#x60;
                          var openSub = on(socket, &#x27;open&#x27;, function() {
                            self.onopen();
                            fn &amp;&amp; fn();
                          });
                        
                          // emit &#x60;connect_error&#x60;
                          var errorSub = on(socket, &#x27;error&#x27;, function(data){
                            debug(&#x27;connect_error&#x27;);
                            self.cleanup();
                            self.readyState = &#x27;closed&#x27;;
                            self.emitAll(&#x27;connect_error&#x27;, data);
                            if (fn) {
                              var err = new Error(&#x27;Connection error&#x27;);
                              err.data = data;
                              fn(err);
                            }
                        
                            self.maybeReconnectOnOpen();
                          });
                        
                          // emit &#x60;connect_timeout&#x60;
                          if (false !== this._timeout) {
                            var timeout = this._timeout;
                            debug(&#x27;connect attempt will timeout after %d&#x27;, timeout);
                        
                            // set timer
                            var timer = setTimeout(function(){
                              debug(&#x27;connect attempt timed out after %d&#x27;, timeout);
                              openSub.destroy();
                              socket.close();
                              socket.emit(&#x27;error&#x27;, &#x27;timeout&#x27;);
                              self.emitAll(&#x27;connect_timeout&#x27;, timeout);
                            }, timeout);
                        
                            this.subs.push({
                              destroy: function(){
                                clearTimeout(timer);
                              }
                            });
                          }
                        
                          this.subs.push(openSub);
                          this.subs.push(errorSub);
                        
                          return this;
                        };
                        
                        /**
                         * Called upon transport open.
                         *
                         * @api private
                         */
                        
                        Manager.prototype.onopen = function(){
                          debug(&#x27;open&#x27;);
                        
                          // clear old subs
                          this.cleanup();
                        
                          // mark as open
                          this.readyState = &#x27;open&#x27;;
                          this.emit(&#x27;open&#x27;);
                        
                          // add new subs
                          var socket = this.engine;
                          this.subs.push(on(socket, &#x27;data&#x27;, bind(this, &#x27;ondata&#x27;)));
                          this.subs.push(on(this.decoder, &#x27;decoded&#x27;, bind(this, &#x27;ondecoded&#x27;)));
                          this.subs.push(on(socket, &#x27;error&#x27;, bind(this, &#x27;onerror&#x27;)));
                          this.subs.push(on(socket, &#x27;close&#x27;, bind(this, &#x27;onclose&#x27;)));
                        };
                        
                        /**
                         * Called with data.
                         *
                         * @api private
                         */
                        
                        Manager.prototype.ondata = function(data){
                          this.decoder.add(data);
                        };
                        
                        /**
                         * Called when parser fully decodes a packet.
                         *
                         * @api private
                         */
                        
                        Manager.prototype.ondecoded = function(packet) {
                          this.emit(&#x27;packet&#x27;, packet);
                        };
                        
                        /**
                         * Called upon socket error.
                         *
                         * @api private
                         */
                        
                        Manager.prototype.onerror = function(err){
                          debug(&#x27;error&#x27;, err);
                          this.emitAll(&#x27;error&#x27;, err);
                        };
                        
                        /**
                         * Creates a new socket for the given &#x60;nsp&#x60;.
                         *
                         * @return {Socket}
                         * @api public
                         */
                        
                        Manager.prototype.socket = function(nsp){
                          var socket = this.nsps[nsp];
                          if (!socket) {
                            socket = new Socket(this, nsp);
                            this.nsps[nsp] = socket;
                            var self = this;
                            socket.on(&#x27;connect&#x27;, function(){
                              if (!~indexOf(self.connected, socket)) {
                                self.connected.push(socket);
                              }
                            });
                          }
                          return socket;
                        };
                        
                        /**
                         * Called upon a socket close.
                         *
                         * @param {Socket} socket
                         */
                        
                        Manager.prototype.destroy = function(socket){
                          var index = indexOf(this.connected, socket);
                          if (~index) this.connected.splice(index, 1);
                          if (this.connected.length) return;
                        
                          this.close();
                        };
                        
                        /**
                         * Writes a packet.
                         *
                         * @param {Object} packet
                         * @api private
                         */
                        
                        Manager.prototype.packet = function(packet){
                          debug(&#x27;writing packet %j&#x27;, packet);
                          var self = this;
                        
                          if (!self.encoding) {
                            // encode, then write to engine with result
                            self.encoding = true;
                            this.encoder.encode(packet, function(encodedPackets) {
                              for (var i = 0; i &lt; encodedPackets.length; i++) {
                                self.engine.write(encodedPackets[i]);
                              }
                              self.encoding = false;
                              self.processPacketQueue();
                            });
                          } else { // add packet to the queue
                            self.packetBuffer.push(packet);
                          }
                        };
                        
                        /**
                         * If packet buffer is non-empty, begins encoding the
                         * next packet in line.
                         *
                         * @api private
                         */
                        
                        Manager.prototype.processPacketQueue = function() {
                          if (this.packetBuffer.length &gt; 0 &amp;&amp; !this.encoding) {
                            var pack = this.packetBuffer.shift();
                            this.packet(pack);
                          }
                        };
                        
                        /**
                         * Clean up transport subscriptions and packet buffer.
                         *
                         * @api private
                         */
                        
                        Manager.prototype.cleanup = function(){
                          var sub;
                          while (sub = this.subs.shift()) sub.destroy();
                        
                          this.packetBuffer = [];
                          this.encoding = false;
                        
                          this.decoder.destroy();
                        };
                        
                        /**
                         * Close the current socket.
                         *
                         * @api private
                         */
                        
                        Manager.prototype.close =
                        Manager.prototype.disconnect = function(){
                          this.skipReconnect = true;
                          this.readyState = &#x27;closed&#x27;;
                          this.engine &amp;&amp; this.engine.close();
                        };
                        
                        /**
                         * Called upon engine close.
                         *
                         * @api private
                         */
                        
                        Manager.prototype.onclose = function(reason){
                          debug(&#x27;close&#x27;);
                          this.cleanup();
                          this.readyState = &#x27;closed&#x27;;
                          this.emit(&#x27;close&#x27;, reason);
                          if (this._reconnection &amp;&amp; !this.skipReconnect) {
                            this.reconnect();
                          }
                        };
                        
                        /**
                         * Attempt a reconnection.
                         *
                         * @api private
                         */
                        
                        Manager.prototype.reconnect = function(){
                          if (this.reconnecting || this.skipReconnect) return this;
                        
                          var self = this;
                          this.attempts++;
                        
                          if (this.attempts &gt; this._reconnectionAttempts) {
                            debug(&#x27;reconnect failed&#x27;);
                            this.emitAll(&#x27;reconnect_failed&#x27;);
                            this.reconnecting = false;
                          } else {
                            var delay = this.attempts * this.reconnectionDelay();
                            delay = Math.min(delay, this.reconnectionDelayMax());
                            debug(&#x27;will wait %dms before reconnect attempt&#x27;, delay);
                        
                            this.reconnecting = true;
                            var timer = setTimeout(function(){
                              if (self.skipReconnect) return;
                        
                              debug(&#x27;attempting reconnect&#x27;);
                              self.emitAll(&#x27;reconnect_attempt&#x27;, self.attempts);
                              self.emitAll(&#x27;reconnecting&#x27;, self.attempts);
                        
                              // check again for the case socket closed in above events
                              if (self.skipReconnect) return;
                        
                              self.open(function(err){
                                if (err) {
                                  debug(&#x27;reconnect attempt error&#x27;);
                                  self.reconnecting = false;
                                  self.reconnect();
                                  self.emitAll(&#x27;reconnect_error&#x27;, err.data);
                                } else {
                                  debug(&#x27;reconnect success&#x27;);
                                  self.onreconnect();
                                }
                              });
                            }, delay);
                        
                            this.subs.push({
                              destroy: function(){
                                clearTimeout(timer);
                              }
                            });
                          }
                        };
                        
                        /**
                         * Called upon successful reconnect.
                         *
                         * @api private
                         */
                        
                        Manager.prototype.onreconnect = function(){
                          var attempt = this.attempts;
                          this.attempts = 0;
                          this.reconnecting = false;
                          this.emitAll(&#x27;reconnect&#x27;, attempt);
                        };
                        
                        },{&quot;./on&quot;:4,&quot;./socket&quot;:5,&quot;./url&quot;:6,&quot;component-bind&quot;:7,&quot;component-emitter&quot;:8,&quot;debug&quot;:9,&quot;engine.io-client&quot;:10,&quot;indexof&quot;:36,&quot;object-component&quot;:37,&quot;socket.io-parser&quot;:40}],4:[function(_dereq_,module,exports){
                        
                        /**
                         * Module exports.
                         */
                        
                        module.exports = on;
                        
                        /**
                         * Helper for subscriptions.
                         *
                         * @param {Object|EventEmitter} obj with &#x60;Emitter&#x60; mixin or &#x60;EventEmitter&#x60;
                         * @param {String} event name
                         * @param {Function} callback
                         * @api public
                         */
                        
                        function on(obj, ev, fn) {
                          obj.on(ev, fn);
                          return {
                            destroy: function(){
                              obj.removeListener(ev, fn);
                            }
                          };
                        }
                        
                        },{}],5:[function(_dereq_,module,exports){
                        
                        /**
                         * Module dependencies.
                         */
                        
                        var parser = _dereq_(&#x27;socket.io-parser&#x27;);
                        var Emitter = _dereq_(&#x27;component-emitter&#x27;);
                        var toArray = _dereq_(&#x27;to-array&#x27;);
                        var on = _dereq_(&#x27;./on&#x27;);
                        var bind = _dereq_(&#x27;component-bind&#x27;);
                        var debug = _dereq_(&#x27;debug&#x27;)(&#x27;socket.io-client:socket&#x27;);
                        var hasBin = _dereq_(&#x27;has-binary&#x27;);
                        
                        /**
                         * Module exports.
                         */
                        
                        module.exports = exports = Socket;
                        
                        /**
                         * Internal events (blacklisted).
                         * These events can&#x27;t be emitted by the user.
                         *
                         * @api private
                         */
                        
                        var events = {
                          connect: 1,
                          connect_error: 1,
                          connect_timeout: 1,
                          disconnect: 1,
                          error: 1,
                          reconnect: 1,
                          reconnect_attempt: 1,
                          reconnect_failed: 1,
                          reconnect_error: 1,
                          reconnecting: 1
                        };
                        
                        /**
                         * Shortcut to &#x60;Emitter#emit&#x60;.
                         */
                        
                        var emit = Emitter.prototype.emit;
                        
                        /**
                         * &#x60;Socket&#x60; constructor.
                         *
                         * @api public
                         */
                        
                        function Socket(io, nsp){
                          this.io = io;
                          this.nsp = nsp;
                          this.json = this; // compat
                          this.ids = 0;
                          this.acks = {};
                          if (this.io.autoConnect) this.open();
                          this.receiveBuffer = [];
                          this.sendBuffer = [];
                          this.connected = false;
                          this.disconnected = true;
                        }
                        
                        /**
                         * Mix in &#x60;Emitter&#x60;.
                         */
                        
                        Emitter(Socket.prototype);
                        
                        /**
                         * Subscribe to open, close and packet events
                         *
                         * @api private
                         */
                        
                        Socket.prototype.subEvents = function() {
                          if (this.subs) return;
                        
                          var io = this.io;
                          this.subs = [
                            on(io, &#x27;open&#x27;, bind(this, &#x27;onopen&#x27;)),
                            on(io, &#x27;packet&#x27;, bind(this, &#x27;onpacket&#x27;)),
                            on(io, &#x27;close&#x27;, bind(this, &#x27;onclose&#x27;))
                          ];
                        };
                        
                        /**
                         * &quot;Opens&quot; the socket.
                         *
                         * @api public
                         */
                        
                        Socket.prototype.open =
                        Socket.prototype.connect = function(){
                          if (this.connected) return this;
                        
                          this.subEvents();
                          this.io.open(); // ensure open
                          if (&#x27;open&#x27; == this.io.readyState) this.onopen();
                          return this;
                        };
                        
                        /**
                         * Sends a &#x60;message&#x60; event.
                         *
                         * @return {Socket} self
                         * @api public
                         */
                        
                        Socket.prototype.send = function(){
                          var args = toArray(arguments);
                          args.unshift(&#x27;message&#x27;);
                          this.emit.apply(this, args);
                          return this;
                        };
                        
                        /**
                         * Override &#x60;emit&#x60;.
                         * If the event is in &#x60;events&#x60;, it&#x27;s emitted normally.
                         *
                         * @param {String} event name
                         * @return {Socket} self
                         * @api public
                         */
                        
                        Socket.prototype.emit = function(ev){
                          if (events.hasOwnProperty(ev)) {
                            emit.apply(this, arguments);
                            return this;
                          }
                        
                          var args = toArray(arguments);
                          var parserType = parser.EVENT; // default
                          if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
                          var packet = { type: parserType, data: args };
                        
                          // event ack callback
                          if (&#x27;function&#x27; == typeof args[args.length - 1]) {
                            debug(&#x27;emitting packet with ack id %d&#x27;, this.ids);
                            this.acks[this.ids] = args.pop();
                            packet.id = this.ids++;
                          }
                        
                          if (this.connected) {
                            this.packet(packet);
                          } else {
                            this.sendBuffer.push(packet);
                          }
                        
                          return this;
                        };
                        
                        /**
                         * Sends a packet.
                         *
                         * @param {Object} packet
                         * @api private
                         */
                        
                        Socket.prototype.packet = function(packet){
                          packet.nsp = this.nsp;
                          this.io.packet(packet);
                        };
                        
                        /**
                         * Called upon engine &#x60;open&#x60;.
                         *
                         * @api private
                         */
                        
                        Socket.prototype.onopen = function(){
                          debug(&#x27;transport is open - connecting&#x27;);
                        
                          // write connect packet if necessary
                          if (&#x27;/&#x27; != this.nsp) {
                            this.packet({ type: parser.CONNECT });
                          }
                        };
                        
                        /**
                         * Called upon engine &#x60;close&#x60;.
                         *
                         * @param {String} reason
                         * @api private
                         */
                        
                        Socket.prototype.onclose = function(reason){
                          debug(&#x27;close (%s)&#x27;, reason);
                          this.connected = false;
                          this.disconnected = true;
                          this.emit(&#x27;disconnect&#x27;, reason);
                        };
                        
                        /**
                         * Called with socket packet.
                         *
                         * @param {Object} packet
                         * @api private
                         */
                        
                        Socket.prototype.onpacket = function(packet){
                          if (packet.nsp != this.nsp) return;
                        
                          switch (packet.type) {
                            case parser.CONNECT:
                              this.onconnect();
                              break;
                        
                            case parser.EVENT:
                              this.onevent(packet);
                              break;
                        
                            case parser.BINARY_EVENT:
                              this.onevent(packet);
                              break;
                        
                            case parser.ACK:
                              this.onack(packet);
                              break;
                        
                            case parser.BINARY_ACK:
                              this.onack(packet);
                              break;
                        
                            case parser.DISCONNECT:
                              this.ondisconnect();
                              break;
                        
                            case parser.ERROR:
                              this.emit(&#x27;error&#x27;, packet.data);
                              break;
                          }
                        };
                        
                        /**
                         * Called upon a server event.
                         *
                         * @param {Object} packet
                         * @api private
                         */
                        
                        Socket.prototype.onevent = function(packet){
                          var args = packet.data || [];
                          debug(&#x27;emitting event %j&#x27;, args);
                        
                          if (null != packet.id) {
                            debug(&#x27;attaching ack callback to event&#x27;);
                            args.push(this.ack(packet.id));
                          }
                        
                          if (this.connected) {
                            emit.apply(this, args);
                          } else {
                            this.receiveBuffer.push(args);
                          }
                        };
                        
                        /**
                         * Produces an ack callback to emit with an event.
                         *
                         * @api private
                         */
                        
                        Socket.prototype.ack = function(id){
                          var self = this;
                          var sent = false;
                          return function(){
                            // prevent double callbacks
                            if (sent) return;
                            sent = true;
                            var args = toArray(arguments);
                            debug(&#x27;sending ack %j&#x27;, args);
                        
                            var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
                            self.packet({
                              type: type,
                              id: id,
                              data: args
                            });
                          };
                        };
                        
                        /**
                         * Called upon a server acknowlegement.
                         *
                         * @param {Object} packet
                         * @api private
                         */
                        
                        Socket.prototype.onack = function(packet){
                          debug(&#x27;calling ack %s with %j&#x27;, packet.id, packet.data);
                          var fn = this.acks[packet.id];
                          fn.apply(this, packet.data);
                          delete this.acks[packet.id];
                        };
                        
                        /**
                         * Called upon server connect.
                         *
                         * @api private
                         */
                        
                        Socket.prototype.onconnect = function(){
                          this.connected = true;
                          this.disconnected = false;
                          this.emit(&#x27;connect&#x27;);
                          this.emitBuffered();
                        };
                        
                        /**
                         * Emit buffered events (received and emitted).
                         *
                         * @api private
                         */
                        
                        Socket.prototype.emitBuffered = function(){
                          var i;
                          for (i = 0; i &lt; this.receiveBuffer.length; i++) {
                            emit.apply(this, this.receiveBuffer[i]);
                          }
                          this.receiveBuffer = [];
                        
                          for (i = 0; i &lt; this.sendBuffer.length; i++) {
                            this.packet(this.sendBuffer[i]);
                          }
                          this.sendBuffer = [];
                        };
                        
                        /**
                         * Called upon server disconnect.
                         *
                         * @api private
                         */
                        
                        Socket.prototype.ondisconnect = function(){
                          debug(&#x27;server disconnect (%s)&#x27;, this.nsp);
                          this.destroy();
                          this.onclose(&#x27;io server disconnect&#x27;);
                        };
                        
                        /**
                         * Called upon forced client/server side disconnections,
                         * this method ensures the manager stops tracking us and
                         * that reconnections don&#x27;t get triggered for this.
                         *
                         * @api private.
                         */
                        
                        Socket.prototype.destroy = function(){
                          if (this.subs) {
                            // clean subscriptions to avoid reconnections
                            for (var i = 0; i &lt; this.subs.length; i++) {
                              this.subs[i].destroy();
                            }
                            this.subs = null;
                          }
                        
                          this.io.destroy(this);
                        };
                        
                        /**
                         * Disconnects the socket manually.
                         *
                         * @return {Socket} self
                         * @api public
                         */
                        
                        Socket.prototype.close =
                        Socket.prototype.disconnect = function(){
                          if (this.connected) {
                            debug(&#x27;performing disconnect (%s)&#x27;, this.nsp);
                            this.packet({ type: parser.DISCONNECT });
                          }
                        
                          // remove socket from pool
                          this.destroy();
                        
                          if (this.connected) {
                            // fire events
                            this.onclose(&#x27;io client disconnect&#x27;);
                          }
                          return this;
                        };
                        
                        },{&quot;./on&quot;:4,&quot;component-bind&quot;:7,&quot;component-emitter&quot;:8,&quot;debug&quot;:9,&quot;has-binary&quot;:32,&quot;socket.io-parser&quot;:40,&quot;to-array&quot;:44}],6:[function(_dereq_,module,exports){
                        (function (global){
                        
                        /**
                         * Module dependencies.
                         */
                        
                        var parseuri = _dereq_(&#x27;parseuri&#x27;);
                        var debug = _dereq_(&#x27;debug&#x27;)(&#x27;socket.io-client:url&#x27;);
                        
                        /**
                         * Module exports.
                         */
                        
                        module.exports = url;
                        
                        /**
                         * URL parser.
                         *
                         * @param {String} url
                         * @param {Object} An object meant to mimic window.location.
                         *                 Defaults to window.location.
                         * @api public
                         */
                        
                        function url(uri, loc){
                          var obj = uri;
                        
                          // default to window.location
                          var loc = loc || global.location;
                          if (null == uri) uri = loc.protocol + &#x27;//&#x27; + loc.hostname;
                        
                          // relative path support
                          if (&#x27;string&#x27; == typeof uri) {
                            if (&#x27;/&#x27; == uri.charAt(0)) {
                              if (&#x27;/&#x27; == uri.charAt(1)) {
                                uri = loc.protocol + uri;
                              } else {
                                uri = loc.hostname + uri;
                              }
                            }
                        
                            if (!/^(https?|wss?):\/\//.test(uri)) {
                              debug(&#x27;protocol-less url %s&#x27;, uri);
                              if (&#x27;undefined&#x27; != typeof loc) {
                                uri = loc.protocol + &#x27;//&#x27; + uri;
                              } else {
                                uri = &#x27;https://&#x27; + uri;
                              }
                            }
                        
                            // parse
                            debug(&#x27;parse %s&#x27;, uri);
                            obj = parseuri(uri);
                          }
                        
                          // make sure we treat &#x60;localhost:80&#x60; and &#x60;localhost&#x60; equally
                          if (!obj.port) {
                            if (/^(http|ws)$/.test(obj.protocol)) {
                              obj.port = &#x27;80&#x27;;
                            }
                            else if (/^(http|ws)s$/.test(obj.protocol)) {
                              obj.port = &#x27;443&#x27;;
                            }
                          }
                        
                          obj.path = obj.path || &#x27;/&#x27;;
                        
                          // define unique id
                          obj.id = obj.protocol + &#x27;://&#x27; + obj.host + &#x27;:&#x27; + obj.port;
                          // define href
                          obj.href = obj.protocol + &#x27;://&#x27; + obj.host + (loc &amp;&amp; loc.port == obj.port ? &#x27;&#x27; : (&#x27;:&#x27; + obj.port));
                        
                          return obj;
                        }
                        
                        }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
                        },{&quot;debug&quot;:9,&quot;parseuri&quot;:38}],7:[function(_dereq_,module,exports){
                        /**
                         * Slice reference.
                         */
                        
                        var slice = [].slice;
                        
                        /**
                         * Bind &#x60;obj&#x60; to &#x60;fn&#x60;.
                         *
                         * @param {Object} obj
                         * @param {Function|String} fn or string
                         * @return {Function}
                         * @api public
                         */
                        
                        module.exports = function(obj, fn){
                          if (&#x27;string&#x27; == typeof fn) fn = obj[fn];
                          if (&#x27;function&#x27; != typeof fn) throw new Error(&#x27;bind() requires a function&#x27;);
                          var args = slice.call(arguments, 2);
                          return function(){
                            return fn.apply(obj, args.concat(slice.call(arguments)));
                          }
                        };
                        
                        },{}],8:[function(_dereq_,module,exports){
                        
                        /**
                         * Expose &#x60;Emitter&#x60;.
                         */
                        
                        module.exports = Emitter;
                        
                        /**
                         * Initialize a new &#x60;Emitter&#x60;.
                         *
                         * @api public
                         */
                        
                        function Emitter(obj) {
                          if (obj) return mixin(obj);
                        };
                        
                        /**
                         * Mixin the emitter properties.
                         *
                         * @param {Object} obj
                         * @return {Object}
                         * @api private
                         */
                        
                        function mixin(obj) {
                          for (var key in Emitter.prototype) {
                            obj[key] = Emitter.prototype[key];
                          }
                          return obj;
                        }
                        
                        /**
                         * Listen on the given &#x60;event&#x60; with &#x60;fn&#x60;.
                         *
                         * @param {String} event
                         * @param {Function} fn
                         * @return {Emitter}
                         * @api public
                         */
                        
                        Emitter.prototype.on =
                        Emitter.prototype.addEventListener = function(event, fn){
                          this._callbacks = this._callbacks || {};
                          (this._callbacks[event] = this._callbacks[event] || [])
                            .push(fn);
                          return this;
                        };
                        
                        /**
                         * Adds an &#x60;event&#x60; listener that will be invoked a single
                         * time then automatically removed.
                         *
                         * @param {String} event
                         * @param {Function} fn
                         * @return {Emitter}
                         * @api public
                         */
                        
                        Emitter.prototype.once = function(event, fn){
                          var self = this;
                          this._callbacks = this._callbacks || {};
                        
                          function on() {
                            self.off(event, on);
                            fn.apply(this, arguments);
                          }
                        
                          on.fn = fn;
                          this.on(event, on);
                          return this;
                        };
                        
                        /**
                         * Remove the given callback for &#x60;event&#x60; or all
                         * registered callbacks.
                         *
                         * @param {String} event
                         * @param {Function} fn
                         * @return {Emitter}
                         * @api public
                         */
                        
                        Emitter.prototype.off =
                        Emitter.prototype.removeListener =
                        Emitter.prototype.removeAllListeners =
                        Emitter.prototype.removeEventListener = function(event, fn){
                          this._callbacks = this._callbacks || {};
                        
                          // all
                          if (0 == arguments.length) {
                            this._callbacks = {};
                            return this;
                          }
                        
                          // specific event
                          var callbacks = this._callbacks[event];
                          if (!callbacks) return this;
                        
                          // remove all handlers
                          if (1 == arguments.length) {
                            delete this._callbacks[event];
                            return this;
                          }
                        
                          // remove specific handler
                          var cb;
                          for (var i = 0; i &lt; callbacks.length; i++) {
                            cb = callbacks[i];
                            if (cb === fn || cb.fn === fn) {
                              callbacks.splice(i, 1);
                              break;
                            }
                          }
                          return this;
                        };
                        
                        /**
                         * Emit &#x60;event&#x60; with the given args.
                         *
                         * @param {String} event
                         * @param {Mixed} ...
                         * @return {Emitter}
                         */
                        
                        Emitter.prototype.emit = function(event){
                          this._callbacks = this._callbacks || {};
                          var args = [].slice.call(arguments, 1)
                            , callbacks = this._callbacks[event];
                        
                          if (callbacks) {
                            callbacks = callbacks.slice(0);
                            for (var i = 0, len = callbacks.length; i &lt; len; ++i) {
                              callbacks[i].apply(this, args);
                            }
                          }
                        
                          return this;
                        };
                        
                        /**
                         * Return array of callbacks for &#x60;event&#x60;.
                         *
                         * @param {String} event
                         * @return {Array}
                         * @api public
                         */
                        
                        Emitter.prototype.listeners = function(event){
                          this._callbacks = this._callbacks || {};
                          return this._callbacks[event] || [];
                        };
                        
                        /**
                         * Check if this emitter has &#x60;event&#x60; handlers.
                         *
                         * @param {String} event
                         * @return {Boolean}
                         * @api public
                         */
                        
                        Emitter.prototype.hasListeners = function(event){
                          return !! this.listeners(event).length;
                        };
                        
                        },{}],9:[function(_dereq_,module,exports){
                        
                        /**
                         * Expose &#x60;debug()&#x60; as the module.
                         */
                        
                        module.exports = debug;
                        
                        /**
                         * Create a debugger with the given &#x60;name&#x60;.
                         *
                         * @param {String} name
                         * @return {Type}
                         * @api public
                         */
                        
                        function debug(name) {
                          if (!debug.enabled(name)) return function(){};
                        
                          return function(fmt){
                            fmt = coerce(fmt);
                        
                            var curr = new Date;
                            var ms = curr - (debug[name] || curr);
                            debug[name] = curr;
                        
                            fmt = name
                              + &#x27; &#x27;
                              + fmt
                              + &#x27; +&#x27; + debug.humanize(ms);
                        
                            // This hackery is required for IE8
                            // where &#x60;console.log&#x60; doesn&#x27;t have &#x27;apply&#x27;
                            window.console
                              &amp;&amp; console.log
                              &amp;&amp; Function.prototype.apply.call(console.log, console, arguments);
                          }
                        }
                        
                        /**
                         * The currently active debug mode names.
                         */
                        
                        debug.names = [];
                        debug.skips = [];
                        
                        /**
                         * Enables a debug mode by name. This can include modes
                         * separated by a colon and wildcards.
                         *
                         * @param {String} name
                         * @api public
                         */
                        
                        debug.enable = function(name) {
                          try {
                            localStorage.debug = name;
                          } catch(e){}
                        
                          var split = (name || &#x27;&#x27;).split(/[\s,]+/)
                            , len = split.length;
                        
                          for (var i = 0; i &lt; len; i++) {
                            name = split[i].replace(&#x27;*&#x27;, &#x27;.*?&#x27;);
                            if (name[0] === &#x27;-&#x27;) {
                              debug.skips.push(new RegExp(&#x27;^&#x27; + name.substr(1) + &#x27;$&#x27;));
                            }
                            else {
                              debug.names.push(new RegExp(&#x27;^&#x27; + name + &#x27;$&#x27;));
                            }
                          }
                        };
                        
                        /**
                         * Disable debug output.
                         *
                         * @api public
                         */
                        
                        debug.disable = function(){
                          debug.enable(&#x27;&#x27;);
                        };
                        
                        /**
                         * Humanize the given &#x60;ms&#x60;.
                         *
                         * @param {Number} m
                         * @return {String}
                         * @api private
                         */
                        
                        debug.humanize = function(ms) {
                          var sec = 1000
                            , min = 60 * 1000
                            , hour = 60 * min;
                        
                          if (ms &gt;= hour) return (ms / hour).toFixed(1) + &#x27;h&#x27;;
                          if (ms &gt;= min) return (ms / min).toFixed(1) + &#x27;m&#x27;;
                          if (ms &gt;= sec) return (ms / sec | 0) + &#x27;s&#x27;;
                          return ms + &#x27;ms&#x27;;
                        };
                        
                        /**
                         * Returns true if the given mode name is enabled, false otherwise.
                         *
                         * @param {String} name
                         * @return {Boolean}
                         * @api public
                         */
                        
                        debug.enabled = function(name) {
                          for (var i = 0, len = debug.skips.length; i &lt; len; i++) {
                            if (debug.skips[i].test(name)) {
                              return false;
                            }
                          }
                          for (var i = 0, len = debug.names.length; i &lt; len; i++) {
                            if (debug.names[i].test(name)) {
                              return true;
                            }
                          }
                          return false;
                        };
                        
                        /**
                         * Coerce &#x60;val&#x60;.
                         */
                        
                        function coerce(val) {
                          if (val instanceof Error) return val.stack || val.message;
                          return val;
                        }
                        
                        // persist
                        
                        try {
                          if (window.localStorage) debug.enable(localStorage.debug);
                        } catch(e){}
                        
                        },{}],10:[function(_dereq_,module,exports){
                        
                        module.exports =  _dereq_(&#x27;./lib/&#x27;);
                        
                        },{&quot;./lib/&quot;:11}],11:[function(_dereq_,module,exports){
                        
                        module.exports = _dereq_(&#x27;./socket&#x27;);
                        
                        /**
                         * Exports parser
                         *
                         * @api public
                         *
                         */
                        module.exports.parser = _dereq_(&#x27;engine.io-parser&#x27;);
                        
                        },{&quot;./socket&quot;:12,&quot;engine.io-parser&quot;:21}],12:[function(_dereq_,module,exports){
                        (function (global){
                        /**
                         * Module dependencies.
                         */
                        
                        var transports = _dereq_(&#x27;./transports&#x27;);
                        var Emitter = _dereq_(&#x27;component-emitter&#x27;);
                        var debug = _dereq_(&#x27;debug&#x27;)(&#x27;engine.io-client:socket&#x27;);
                        var index = _dereq_(&#x27;indexof&#x27;);
                        var parser = _dereq_(&#x27;engine.io-parser&#x27;);
                        var parseuri = _dereq_(&#x27;parseuri&#x27;);
                        var parsejson = _dereq_(&#x27;parsejson&#x27;);
                        var parseqs = _dereq_(&#x27;parseqs&#x27;);
                        
                        /**
                         * Module exports.
                         */
                        
                        module.exports = Socket;
                        
                        /**
                         * Noop function.
                         *
                         * @api private
                         */
                        
                        function noop(){}
                        
                        /**
                         * Socket constructor.
                         *
                         * @param {String|Object} uri or options
                         * @param {Object} options
                         * @api public
                         */
                        
                        function Socket(uri, opts){
                          if (!(this instanceof Socket)) return new Socket(uri, opts);
                        
                          opts = opts || {};
                        
                          if (uri &amp;&amp; &#x27;object&#x27; == typeof uri) {
                            opts = uri;
                            uri = null;
                          }
                        
                          if (uri) {
                            uri = parseuri(uri);
                            opts.host = uri.host;
                            opts.secure = uri.protocol == &#x27;https&#x27; || uri.protocol == &#x27;wss&#x27;;
                            opts.port = uri.port;
                            if (uri.query) opts.query = uri.query;
                          }
                        
                          this.secure = null != opts.secure ? opts.secure :
                            (global.location &amp;&amp; &#x27;https:&#x27; == location.protocol);
                        
                          if (opts.host) {
                            var pieces = opts.host.split(&#x27;:&#x27;);
                            opts.hostname = pieces.shift();
                            if (pieces.length) opts.port = pieces.pop();
                          }
                        
                          this.agent = opts.agent || false;
                          this.hostname = opts.hostname ||
                            (global.location ? location.hostname : &#x27;localhost&#x27;);
                          this.port = opts.port || (global.location &amp;&amp; location.port ?
                               location.port :
                               (this.secure ? 443 : 80));
                          this.query = opts.query || {};
                          if (&#x27;string&#x27; == typeof this.query) this.query = parseqs.decode(this.query);
                          this.upgrade = false !== opts.upgrade;
                          this.path = (opts.path || &#x27;/engine.io&#x27;).replace(/\/$/, &#x27;&#x27;) + &#x27;/&#x27;;
                          this.forceJSONP = !!opts.forceJSONP;
                          this.jsonp = false !== opts.jsonp;
                          this.forceBase64 = !!opts.forceBase64;
                          this.enablesXDR = !!opts.enablesXDR;
                          this.timestampParam = opts.timestampParam || &#x27;t&#x27;;
                          this.timestampRequests = opts.timestampRequests;
                          this.transports = opts.transports || [&#x27;polling&#x27;, &#x27;websocket&#x27;];
                          this.readyState = &#x27;&#x27;;
                          this.writeBuffer = [];
                          this.callbackBuffer = [];
                          this.policyPort = opts.policyPort || 843;
                          this.rememberUpgrade = opts.rememberUpgrade || false;
                          this.open();
                          this.binaryType = null;
                          this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
                        }
                        
                        Socket.priorWebsocketSuccess = false;
                        
                        /**
                         * Mix in &#x60;Emitter&#x60;.
                         */
                        
                        Emitter(Socket.prototype);
                        
                        /**
                         * Protocol version.
                         *
                         * @api public
                         */
                        
                        Socket.protocol = parser.protocol; // this is an int
                        
                        /**
                         * Expose deps for legacy compatibility
                         * and standalone browser access.
                         */
                        
                        Socket.Socket = Socket;
                        Socket.Transport = _dereq_(&#x27;./transport&#x27;);
                        Socket.transports = _dereq_(&#x27;./transports&#x27;);
                        Socket.parser = _dereq_(&#x27;engine.io-parser&#x27;);
                        
                        /**
                         * Creates transport of the given type.
                         *
                         * @param {String} transport name
                         * @return {Transport}
                         * @api private
                         */
                        
                        Socket.prototype.createTransport = function (name) {
                          debug(&#x27;creating transport &quot;%s&quot;&#x27;, name);
                          var query = clone(this.query);
                        
                          // append engine.io protocol identifier
                          query.EIO = parser.protocol;
                        
                          // transport name
                          query.transport = name;
                        
                          // session id if we already have one
                          if (this.id) query.sid = this.id;
                        
                          var transport = new transports[name]({
                            agent: this.agent,
                            hostname: this.hostname,
                            port: this.port,
                            secure: this.secure,
                            path: this.path,
                            query: query,
                            forceJSONP: this.forceJSONP,
                            jsonp: this.jsonp,
                            forceBase64: this.forceBase64,
                            enablesXDR: this.enablesXDR,
                            timestampRequests: this.timestampRequests,
                            timestampParam: this.timestampParam,
                            policyPort: this.policyPort,
                            socket: this
                          });
                        
                          return transport;
                        };
                        
                        function clone (obj) {
                          var o = {};
                          for (var i in obj) {
                            if (obj.hasOwnProperty(i)) {
                              o[i] = obj[i];
                            }
                          }
                          return o;
                        }
                        
                        /**
                         * Initializes transport to use and starts probe.
                         *
                         * @api private
                         */
                        Socket.prototype.open = function () {
                          var transport;
                          if (this.rememberUpgrade &amp;&amp; Socket.priorWebsocketSuccess &amp;&amp; this.transports.indexOf(&#x27;websocket&#x27;) != -1) {
                            transport = &#x27;websocket&#x27;;
                          } else if (0 == this.transports.length) {
                            // Emit error on next tick so it can be listened to
                            var self = this;
                            setTimeout(function() {
                              self.emit(&#x27;error&#x27;, &#x27;No transports available&#x27;);
                            }, 0);
                            return;
                          } else {
                            transport = this.transports[0];
                          }
                          this.readyState = &#x27;opening&#x27;;
                        
                          // Retry with the next transport if the transport is disabled (jsonp: false)
                          var transport;
                          try {
                            transport = this.createTransport(transport);
                          } catch (e) {
                            this.transports.shift();
                            this.open();
                            return;
                          }
                        
                          transport.open();
                          this.setTransport(transport);
                        };
                        
                        /**
                         * Sets the current transport. Disables the existing one (if any).
                         *
                         * @api private
                         */
                        
                        Socket.prototype.setTransport = function(transport){
                          debug(&#x27;setting transport %s&#x27;, transport.name);
                          var self = this;
                        
                          if (this.transport) {
                            debug(&#x27;clearing existing transport %s&#x27;, this.transport.name);
                            this.transport.removeAllListeners();
                          }
                        
                          // set up transport
                          this.transport = transport;
                        
                          // set up transport listeners
                          transport
                          .on(&#x27;drain&#x27;, function(){
                            self.onDrain();
                          })
                          .on(&#x27;packet&#x27;, function(packet){
                            self.onPacket(packet);
                          })
                          .on(&#x27;error&#x27;, function(e){
                            self.onError(e);
                          })
                          .on(&#x27;close&#x27;, function(){
                            self.onClose(&#x27;transport close&#x27;);
                          });
                        };
                        
                        /**
                         * Probes a transport.
                         *
                         * @param {String} transport name
                         * @api private
                         */
                        
                        Socket.prototype.probe = function (name) {
                          debug(&#x27;probing transport &quot;%s&quot;&#x27;, name);
                          var transport = this.createTransport(name, { probe: 1 })
                            , failed = false
                            , self = this;
                        
                          Socket.priorWebsocketSuccess = false;
                        
                          function onTransportOpen(){
                            if (self.onlyBinaryUpgrades) {
                              var upgradeLosesBinary = !this.supportsBinary &amp;&amp; self.transport.supportsBinary;
                              failed = failed || upgradeLosesBinary;
                            }
                            if (failed) return;
                        
                            debug(&#x27;probe transport &quot;%s&quot; opened&#x27;, name);
                            transport.send([{ type: &#x27;ping&#x27;, data: &#x27;probe&#x27; }]);
                            transport.once(&#x27;packet&#x27;, function (msg) {
                              if (failed) return;
                              if (&#x27;pong&#x27; == msg.type &amp;&amp; &#x27;probe&#x27; == msg.data) {
                                debug(&#x27;probe transport &quot;%s&quot; pong&#x27;, name);
                                self.upgrading = true;
                                self.emit(&#x27;upgrading&#x27;, transport);
                                if (!transport) return;
                                Socket.priorWebsocketSuccess = &#x27;websocket&#x27; == transport.name;
                        
                                debug(&#x27;pausing current transport &quot;%s&quot;&#x27;, self.transport.name);
                                self.transport.pause(function () {
                                  if (failed) return;
                                  if (&#x27;closed&#x27; == self.readyState) return;
                                  debug(&#x27;changing transport and sending upgrade packet&#x27;);
                        
                                  cleanup();
                        
                                  self.setTransport(transport);
                                  transport.send([{ type: &#x27;upgrade&#x27; }]);
                                  self.emit(&#x27;upgrade&#x27;, transport);
                                  transport = null;
                                  self.upgrading = false;
                                  self.flush();
                                });
                              } else {
                                debug(&#x27;probe transport &quot;%s&quot; failed&#x27;, name);
                                var err = new Error(&#x27;probe error&#x27;);
                                err.transport = transport.name;
                                self.emit(&#x27;upgradeError&#x27;, err);
                              }
                            });
                          }
                        
                          function freezeTransport() {
                            if (failed) return;
                        
                            // Any callback called by transport should be ignored since now
                            failed = true;
                        
                            cleanup();
                        
                            transport.close();
                            transport = null;
                          }
                        
                          //Handle any error that happens while probing
                          function onerror(err) {
                            var error = new Error(&#x27;probe error: &#x27; + err);
                            error.transport = transport.name;
                        
                            freezeTransport();
                        
                            debug(&#x27;probe transport &quot;%s&quot; failed because of error: %s&#x27;, name, err);
                        
                            self.emit(&#x27;upgradeError&#x27;, error);
                          }
                        
                          function onTransportClose(){
                            onerror(&quot;transport closed&quot;);
                          }
                        
                          //When the socket is closed while we&#x27;re probing
                          function onclose(){
                            onerror(&quot;socket closed&quot;);
                          }
                        
                          //When the socket is upgraded while we&#x27;re probing
                          function onupgrade(to){
                            if (transport &amp;&amp; to.name != transport.name) {
                              debug(&#x27;&quot;%s&quot; works - aborting &quot;%s&quot;&#x27;, to.name, transport.name);
                              freezeTransport();
                            }
                          }
                        
                          //Remove all listeners on the transport and on self
                          function cleanup(){
                            transport.removeListener(&#x27;open&#x27;, onTransportOpen);
                            transport.removeListener(&#x27;error&#x27;, onerror);
                            transport.removeListener(&#x27;close&#x27;, onTransportClose);
                            self.removeListener(&#x27;close&#x27;, onclose);
                            self.removeListener(&#x27;upgrading&#x27;, onupgrade);
                          }
                        
                          transport.once(&#x27;open&#x27;, onTransportOpen);
                          transport.once(&#x27;error&#x27;, onerror);
                          transport.once(&#x27;close&#x27;, onTransportClose);
                        
                          this.once(&#x27;close&#x27;, onclose);
                          this.once(&#x27;upgrading&#x27;, onupgrade);
                        
                          transport.open();
                        
                        };
                        
                        /**
                         * Called when connection is deemed open.
                         *
                         * @api public
                         */
                        
                        Socket.prototype.onOpen = function () {
                          debug(&#x27;socket open&#x27;);
                          this.readyState = &#x27;open&#x27;;
                          Socket.priorWebsocketSuccess = &#x27;websocket&#x27; == this.transport.name;
                          this.emit(&#x27;open&#x27;);
                          this.flush();
                        
                          // we check for &#x60;readyState&#x60; in case an &#x60;open&#x60;
                          // listener already closed the socket
                          if (&#x27;open&#x27; == this.readyState &amp;&amp; this.upgrade &amp;&amp; this.transport.pause) {
                            debug(&#x27;starting upgrade probes&#x27;);
                            for (var i = 0, l = this.upgrades.length; i &lt; l; i++) {
                              this.probe(this.upgrades[i]);
                            }
                          }
                        };
                        
                        /**
                         * Handles a packet.
                         *
                         * @api private
                         */
                        
                        Socket.prototype.onPacket = function (packet) {
                          if (&#x27;opening&#x27; == this.readyState || &#x27;open&#x27; == this.readyState) {
                            debug(&#x27;socket receive: type &quot;%s&quot;, data &quot;%s&quot;&#x27;, packet.type, packet.data);
                        
                            this.emit(&#x27;packet&#x27;, packet);
                        
                            // Socket is live - any packet counts
                            this.emit(&#x27;heartbeat&#x27;);
                        
                            switch (packet.type) {
                              case &#x27;open&#x27;:
                                this.onHandshake(parsejson(packet.data));
                                break;
                        
                              case &#x27;pong&#x27;:
                                this.setPing();
                                break;
                        
                              case &#x27;error&#x27;:
                                var err = new Error(&#x27;server error&#x27;);
                                err.code = packet.data;
                                this.emit(&#x27;error&#x27;, err);
                                break;
                        
                              case &#x27;message&#x27;:
                                this.emit(&#x27;data&#x27;, packet.data);
                                this.emit(&#x27;message&#x27;, packet.data);
                                break;
                            }
                          } else {
                            debug(&#x27;packet received with socket readyState &quot;%s&quot;&#x27;, this.readyState);
                          }
                        };
                        
                        /**
                         * Called upon handshake completion.
                         *
                         * @param {Object} handshake obj
                         * @api private
                         */
                        
                        Socket.prototype.onHandshake = function (data) {
                          this.emit(&#x27;handshake&#x27;, data);
                          this.id = data.sid;
                          this.transport.query.sid = data.sid;
                          this.upgrades = this.filterUpgrades(data.upgrades);
                          this.pingInterval = data.pingInterval;
                          this.pingTimeout = data.pingTimeout;
                          this.onOpen();
                          // In case open handler closes socket
                          if  (&#x27;closed&#x27; == this.readyState) return;
                          this.setPing();
                        
                          // Prolong liveness of socket on heartbeat
                          this.removeListener(&#x27;heartbeat&#x27;, this.onHeartbeat);
                          this.on(&#x27;heartbeat&#x27;, this.onHeartbeat);
                        };
                        
                        /**
                         * Resets ping timeout.
                         *
                         * @api private
                         */
                        
                        Socket.prototype.onHeartbeat = function (timeout) {
                          clearTimeout(this.pingTimeoutTimer);
                          var self = this;
                          self.pingTimeoutTimer = setTimeout(function () {
                            if (&#x27;closed&#x27; == self.readyState) return;
                            self.onClose(&#x27;ping timeout&#x27;);
                          }, timeout || (self.pingInterval + self.pingTimeout));
                        };
                        
                        /**
                         * Pings server every &#x60;this.pingInterval&#x60; and expects response
                         * within &#x60;this.pingTimeout&#x60; or closes connection.
                         *
                         * @api private
                         */
                        
                        Socket.prototype.setPing = function () {
                          var self = this;
                          clearTimeout(self.pingIntervalTimer);
                          self.pingIntervalTimer = setTimeout(function () {
                            debug(&#x27;writing ping packet - expecting pong within %sms&#x27;, self.pingTimeout);
                            self.ping();
                            self.onHeartbeat(self.pingTimeout);
                          }, self.pingInterval);
                        };
                        
                        /**
                        * Sends a ping packet.
                        *
                        * @api public
                        */
                        
                        Socket.prototype.ping = function () {
                          this.sendPacket(&#x27;ping&#x27;);
                        };
                        
                        /**
                         * Called on &#x60;drain&#x60; event
                         *
                         * @api private
                         */
                        
                        Socket.prototype.onDrain = function() {
                          for (var i = 0; i &lt; this.prevBufferLen; i++) {
                            if (this.callbackBuffer[i]) {
                              this.callbackBuffer[i]();
                            }
                          }
                        
                          this.writeBuffer.splice(0, this.prevBufferLen);
                          this.callbackBuffer.splice(0, this.prevBufferLen);
                        
                          // setting prevBufferLen = 0 is very important
                          // for example, when upgrading, upgrade packet is sent over,
                          // and a nonzero prevBufferLen could cause problems on &#x60;drain&#x60;
                          this.prevBufferLen = 0;
                        
                          if (this.writeBuffer.length == 0) {
                            this.emit(&#x27;drain&#x27;);
                          } else {
                            this.flush();
                          }
                        };
                        
                        /**
                         * Flush write buffers.
                         *
                         * @api private
                         */
                        
                        Socket.prototype.flush = function () {
                          if (&#x27;closed&#x27; != this.readyState &amp;&amp; this.transport.writable &amp;&amp;
                            !this.upgrading &amp;&amp; this.writeBuffer.length) {
                            debug(&#x27;flushing %d packets in socket&#x27;, this.writeBuffer.length);
                            this.transport.send(this.writeBuffer);
                            // keep track of current length of writeBuffer
                            // splice writeBuffer and callbackBuffer on &#x60;drain&#x60;
                            this.prevBufferLen = this.writeBuffer.length;
                            this.emit(&#x27;flush&#x27;);
                          }
                        };
                        
                        /**
                         * Sends a message.
                         *
                         * @param {String} message.
                         * @param {Function} callback function.
                         * @return {Socket} for chaining.
                         * @api public
                         */
                        
                        Socket.prototype.write =
                        Socket.prototype.send = function (msg, fn) {
                          this.sendPacket(&#x27;message&#x27;, msg, fn);
                          return this;
                        };
                        
                        /**
                         * Sends a packet.
                         *
                         * @param {String} packet type.
                         * @param {String} data.
                         * @param {Function} callback function.
                         * @api private
                         */
                        
                        Socket.prototype.sendPacket = function (type, data, fn) {
                          if (&#x27;closing&#x27; == this.readyState || &#x27;closed&#x27; == this.readyState) {
                            return;
                          }
                        
                          var packet = { type: type, data: data };
                          this.emit(&#x27;packetCreate&#x27;, packet);
                          this.writeBuffer.push(packet);
                          this.callbackBuffer.push(fn);
                          this.flush();
                        };
                        
                        /**
                         * Closes the connection.
                         *
                         * @api private
                         */
                        
                        Socket.prototype.close = function () {
                          if (&#x27;opening&#x27; == this.readyState || &#x27;open&#x27; == this.readyState) {
                            this.readyState = &#x27;closing&#x27;;
                        
                            var self = this;
                        
                            function close() {
                              self.onClose(&#x27;forced close&#x27;);
                              debug(&#x27;socket closing - telling transport to close&#x27;);
                              self.transport.close();
                            }
                        
                            function cleanupAndClose() {
                              self.removeListener(&#x27;upgrade&#x27;, cleanupAndClose);
                              self.removeListener(&#x27;upgradeError&#x27;, cleanupAndClose);
                              close();
                            }
                        
                            function waitForUpgrade() {
                              // wait for upgrade to finish since we can&#x27;t send packets while pausing a transport
                              self.once(&#x27;upgrade&#x27;, cleanupAndClose);
                              self.once(&#x27;upgradeError&#x27;, cleanupAndClose);
                            }
                        
                            if (this.writeBuffer.length) {
                              this.once(&#x27;drain&#x27;, function() {
                                if (this.upgrading) {
                                  waitForUpgrade();
                                } else {
                                  close();
                                }
                              });
                            } else if (this.upgrading) {
                              waitForUpgrade();
                            } else {
                              close();
                            }
                          }
                        
                          return this;
                        };
                        
                        /**
                         * Called upon transport error
                         *
                         * @api private
                         */
                        
                        Socket.prototype.onError = function (err) {
                          debug(&#x27;socket error %j&#x27;, err);
                          Socket.priorWebsocketSuccess = false;
                          this.emit(&#x27;error&#x27;, err);
                          this.onClose(&#x27;transport error&#x27;, err);
                        };
                        
                        /**
                         * Called upon transport close.
                         *
                         * @api private
                         */
                        
                        Socket.prototype.onClose = function (reason, desc) {
                          if (&#x27;opening&#x27; == this.readyState || &#x27;open&#x27; == this.readyState || &#x27;closing&#x27; == this.readyState) {
                            debug(&#x27;socket close with reason: &quot;%s&quot;&#x27;, reason);
                            var self = this;
                        
                            // clear timers
                            clearTimeout(this.pingIntervalTimer);
                            clearTimeout(this.pingTimeoutTimer);
                        
                            // clean buffers in next tick, so developers can still
                            // grab the buffers on &#x60;close&#x60; event
                            setTimeout(function() {
                              self.writeBuffer = [];
                              self.callbackBuffer = [];
                              self.prevBufferLen = 0;
                            }, 0);
                        
                            // stop event from firing again for transport
                            this.transport.removeAllListeners(&#x27;close&#x27;);
                        
                            // ensure transport won&#x27;t stay open
                            this.transport.close();
                        
                            // ignore further transport communication
                            this.transport.removeAllListeners();
                        
                            // set ready state
                            this.readyState = &#x27;closed&#x27;;
                        
                            // clear session id
                            this.id = null;
                        
                            // emit close event
                            this.emit(&#x27;close&#x27;, reason, desc);
                          }
                        };
                        
                        /**
                         * Filters upgrades, returning only those matching client transports.
                         *
                         * @param {Array} server upgrades
                         * @api private
                         *
                         */
                        
                        Socket.prototype.filterUpgrades = function (upgrades) {
                          var filteredUpgrades = [];
                          for (var i = 0, j = upgrades.length; i&lt;j; i++) {
                            if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
                          }
                          return filteredUpgrades;
                        };
                        
                        }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
                        },{&quot;./transport&quot;:13,&quot;./transports&quot;:14,&quot;component-emitter&quot;:8,&quot;debug&quot;:9,&quot;engine.io-parser&quot;:21,&quot;indexof&quot;:36,&quot;parsejson&quot;:28,&quot;parseqs&quot;:29,&quot;parseuri&quot;:30}],13:[function(_dereq_,module,exports){
                        /**
                         * Module dependencies.
                         */
                        
                        var parser = _dereq_(&#x27;engine.io-parser&#x27;);
                        var Emitter = _dereq_(&#x27;component-emitter&#x27;);
                        
                        /**
                         * Module exports.
                         */
                        
                        module.exports = Transport;
                        
                        /**
                         * Transport abstract constructor.
                         *
                         * @param {Object} options.
                         * @api private
                         */
                        
                        function Transport (opts) {
                          this.path = opts.path;
                          this.hostname = opts.hostname;
                          this.port = opts.port;
                          this.secure = opts.secure;
                          this.query = opts.query;
                          this.timestampParam = opts.timestampParam;
                          this.timestampRequests = opts.timestampRequests;
                          this.readyState = &#x27;&#x27;;
                          this.agent = opts.agent || false;
                          this.socket = opts.socket;
                          this.enablesXDR = opts.enablesXDR;
                        }
                        
                        /**
                         * Mix in &#x60;Emitter&#x60;.
                         */
                        
                        Emitter(Transport.prototype);
                        
                        /**
                         * A counter used to prevent collisions in the timestamps used
                         * for cache busting.
                         */
                        
                        Transport.timestamps = 0;
                        
                        /**
                         * Emits an error.
                         *
                         * @param {String} str
                         * @return {Transport} for chaining
                         * @api public
                         */
                        
                        Transport.prototype.onError = function (msg, desc) {
                          var err = new Error(msg);
                          err.type = &#x27;TransportError&#x27;;
                          err.description = desc;
                          this.emit(&#x27;error&#x27;, err);
                          return this;
                        };
                        
                        /**
                         * Opens the transport.
                         *
                         * @api public
                         */
                        
                        Transport.prototype.open = function () {
                          if (&#x27;closed&#x27; == this.readyState || &#x27;&#x27; == this.readyState) {
                            this.readyState = &#x27;opening&#x27;;
                            this.doOpen();
                          }
                        
                          return this;
                        };
                        
                        /**
                         * Closes the transport.
                         *
                         * @api private
                         */
                        
                        Transport.prototype.close = function () {
                          if (&#x27;opening&#x27; == this.readyState || &#x27;open&#x27; == this.readyState) {
                            this.doClose();
                            this.onClose();
                          }
                        
                          return this;
                        };
                        
                        /**
                         * Sends multiple packets.
                         *
                         * @param {Array} packets
                         * @api private
                         */
                        
                        Transport.prototype.send = function(packets){
                          if (&#x27;open&#x27; == this.readyState) {
                            this.write(packets);
                          } else {
                            throw new Error(&#x27;Transport not open&#x27;);
                          }
                        };
                        
                        /**
                         * Called upon open
                         *
                         * @api private
                         */
                        
                        Transport.prototype.onOpen = function () {
                          this.readyState = &#x27;open&#x27;;
                          this.writable = true;
                          this.emit(&#x27;open&#x27;);
                        };
                        
                        /**
                         * Called with data.
                         *
                         * @param {String} data
                         * @api private
                         */
                        
                        Transport.prototype.onData = function(data){
                          var packet = parser.decodePacket(data, this.socket.binaryType);
                          this.onPacket(packet);
                        };
                        
                        /**
                         * Called with a decoded packet.
                         */
                        
                        Transport.prototype.onPacket = function (packet) {
                          this.emit(&#x27;packet&#x27;, packet);
                        };
                        
                        /**
                         * Called upon close.
                         *
                         * @api private
                         */
                        
                        Transport.prototype.onClose = function () {
                          this.readyState = &#x27;closed&#x27;;
                          this.emit(&#x27;close&#x27;);
                        };
                        
                        },{&quot;component-emitter&quot;:8,&quot;engine.io-parser&quot;:21}],14:[function(_dereq_,module,exports){
                        (function (global){
                        /**
                         * Module dependencies
                         */
                        
                        var XMLHttpRequest = _dereq_(&#x27;xmlhttprequest&#x27;);
                        var XHR = _dereq_(&#x27;./polling-xhr&#x27;);
                        var JSONP = _dereq_(&#x27;./polling-jsonp&#x27;);
                        var websocket = _dereq_(&#x27;./websocket&#x27;);
                        
                        /**
                         * Export transports.
                         */
                        
                        exports.polling = polling;
                        exports.websocket = websocket;
                        
                        /**
                         * Polling transport polymorphic constructor.
                         * Decides on xhr vs jsonp based on feature detection.
                         *
                         * @api private
                         */
                        
                        function polling(opts){
                          var xhr;
                          var xd = false;
                          var xs = false;
                          var jsonp = false !== opts.jsonp;
                        
                          if (global.location) {
                            var isSSL = &#x27;https:&#x27; == location.protocol;
                            var port = location.port;
                        
                            // some user agents have empty &#x60;location.port&#x60;
                            if (!port) {
                              port = isSSL ? 443 : 80;
                            }
                        
                            xd = opts.hostname != location.hostname || port != opts.port;
                            xs = opts.secure != isSSL;
                          }
                        
                          opts.xdomain = xd;
                          opts.xscheme = xs;
                          xhr = new XMLHttpRequest(opts);
                        
                          if (&#x27;open&#x27; in xhr &amp;&amp; !opts.forceJSONP) {
                            return new XHR(opts);
                          } else {
                            if (!jsonp) throw new Error(&#x27;JSONP disabled&#x27;);
                            return new JSONP(opts);
                          }
                        }
                        
                        }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
                        },{&quot;./polling-jsonp&quot;:15,&quot;./polling-xhr&quot;:16,&quot;./websocket&quot;:18,&quot;xmlhttprequest&quot;:19}],15:[function(_dereq_,module,exports){
                        (function (global){
                        
                        /**
                         * Module requirements.
                         */
                        
                        var Polling = _dereq_(&#x27;./polling&#x27;);
                        var inherit = _dereq_(&#x27;component-inherit&#x27;);
                        
                        /**
                         * Module exports.
                         */
                        
                        module.exports = JSONPPolling;
                        
                        /**
                         * Cached regular expressions.
                         */
                        
                        var rNewline = /\n/g;
                        var rEscapedNewline = /\\n/g;
                        
                        /**
                         * Global JSONP callbacks.
                         */
                        
                        var callbacks;
                        
                        /**
                         * Callbacks count.
                         */
                        
                        var index = 0;
                        
                        /**
                         * Noop.
                         */
                        
                        function empty () { }
                        
                        /**
                         * JSONP Polling constructor.
                         *
                         * @param {Object} opts.
                         * @api public
                         */
                        
                        function JSONPPolling (opts) {
                          Polling.call(this, opts);
                        
                          this.query = this.query || {};
                        
                          // define global callbacks array if not present
                          // we do this here (lazily) to avoid unneeded global pollution
                          if (!callbacks) {
                            // we need to consider multiple engines in the same page
                            if (!global.___eio) global.___eio = [];
                            callbacks = global.___eio;
                          }
                        
                          // callback identifier
                          this.index = callbacks.length;
                        
                          // add callback to jsonp global
                          var self = this;
                          callbacks.push(function (msg) {
                            self.onData(msg);
                          });
                        
                          // append to query string
                          this.query.j = this.index;
                        
                          // prevent spurious errors from being emitted when the window is unloaded
                          if (global.document &amp;&amp; global.addEventListener) {
                            global.addEventListener(&#x27;beforeunload&#x27;, function () {
                              if (self.script) self.script.onerror = empty;
                            });
                          }
                        }
                        
                        /**
                         * Inherits from Polling.
                         */
                        
                        inherit(JSONPPolling, Polling);
                        
                        /*
                         * JSONP only supports binary as base64 encoded strings
                         */
                        
                        JSONPPolling.prototype.supportsBinary = false;
                        
                        /**
                         * Closes the socket.
                         *
                         * @api private
                         */
                        
                        JSONPPolling.prototype.doClose = function () {
                          if (this.script) {
                            this.script.parentNode.removeChild(this.script);
                            this.script = null;
                          }
                        
                          if (this.form) {
                            this.form.parentNode.removeChild(this.form);
                            this.form = null;
                            this.iframe = null;
                          }
                        
                          Polling.prototype.doClose.call(this);
                        };
                        
                        /**
                         * Starts a poll cycle.
                         *
                         * @api private
                         */
                        
                        JSONPPolling.prototype.doPoll = function () {
                          var self = this;
                          var script = document.createElement(&#x27;script&#x27;);
                        
                          if (this.script) {
                            this.script.parentNode.removeChild(this.script);
                            this.script = null;
                          }
                        
                          script.async = true;
                          script.src = this.uri();
                          script.onerror = function(e){
                            self.onError(&#x27;jsonp poll error&#x27;,e);
                          };
                        
                          var insertAt = document.getElementsByTagName(&#x27;script&#x27;)[0];
                          insertAt.parentNode.insertBefore(script, insertAt);
                          this.script = script;
                        
                          var isUAgecko = &#x27;undefined&#x27; != typeof navigator &amp;&amp; /gecko/i.test(navigator.userAgent);
                          
                          if (isUAgecko) {
                            setTimeout(function () {
                              var iframe = document.createElement(&#x27;iframe&#x27;);
                              document.body.appendChild(iframe);
                              document.body.removeChild(iframe);
                            }, 100);
                          }
                        };
                        
                        /**
                         * Writes with a hidden iframe.
                         *
                         * @param {String} data to send
                         * @param {Function} called upon flush.
                         * @api private
                         */
                        
                        JSONPPolling.prototype.doWrite = function (data, fn) {
                          var self = this;
                        
                          if (!this.form) {
                            var form = document.createElement(&#x27;form&#x27;);
                            var area = document.createElement(&#x27;textarea&#x27;);
                            var id = this.iframeId = &#x27;eio_iframe_&#x27; + this.index;
                            var iframe;
                        
                            form.className = &#x27;socketio&#x27;;
                            form.style.position = &#x27;absolute&#x27;;
                            form.style.top = &#x27;-1000px&#x27;;
                            form.style.left = &#x27;-1000px&#x27;;
                            form.target = id;
                            form.method = &#x27;POST&#x27;;
                            form.setAttribute(&#x27;accept-charset&#x27;, &#x27;utf-8&#x27;);
                            area.name = &#x27;d&#x27;;
                            form.appendChild(area);
                            document.body.appendChild(form);
                        
                            this.form = form;
                            this.area = area;
                          }
                        
                          this.form.action = this.uri();
                        
                          function complete () {
                            initIframe();
                            fn();
                          }
                        
                          function initIframe () {
                            if (self.iframe) {
                              try {
                                self.form.removeChild(self.iframe);
                              } catch (e) {
                                self.onError(&#x27;jsonp polling iframe removal error&#x27;, e);
                              }
                            }
                        
                            try {
                              // ie6 dynamic iframes with target=&quot;&quot; support (thanks Chris Lambacher)
                              var html = &#x27;&lt;iframe src=&quot;javascript:0&quot; name=&quot;&#x27;+ self.iframeId +&#x27;&quot;&gt;&#x27;;
                              iframe = document.createElement(html);
                            } catch (e) {
                              iframe = document.createElement(&#x27;iframe&#x27;);
                              iframe.name = self.iframeId;
                              iframe.src = &#x27;javascript:0&#x27;;
                            }
                        
                            iframe.id = self.iframeId;
                        
                            self.form.appendChild(iframe);
                            self.iframe = iframe;
                          }
                        
                          initIframe();
                        
                          // escape \n to prevent it from being converted into \r\n by some UAs
                          // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
                          data = data.replace(rEscapedNewline, &#x27;\\\n&#x27;);
                          this.area.value = data.replace(rNewline, &#x27;\\n&#x27;);
                        
                          try {
                            this.form.submit();
                          } catch(e) {}
                        
                          if (this.iframe.attachEvent) {
                            this.iframe.onreadystatechange = function(){
                              if (self.iframe.readyState == &#x27;complete&#x27;) {
                                complete();
                              }
                            };
                          } else {
                            this.iframe.onload = complete;
                          }
                        };
                        
                        }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
                        },{&quot;./polling&quot;:17,&quot;component-inherit&quot;:20}],16:[function(_dereq_,module,exports){
                        (function (global){
                        /**
                         * Module requirements.
                         */
                        
                        var XMLHttpRequest = _dereq_(&#x27;xmlhttprequest&#x27;);
                        var Polling = _dereq_(&#x27;./polling&#x27;);
                        var Emitter = _dereq_(&#x27;component-emitter&#x27;);
                        var inherit = _dereq_(&#x27;component-inherit&#x27;);
                        var debug = _dereq_(&#x27;debug&#x27;)(&#x27;engine.io-client:polling-xhr&#x27;);
                        
                        /**
                         * Module exports.
                         */
                        
                        module.exports = XHR;
                        module.exports.Request = Request;
                        
                        /**
                         * Empty function
                         */
                        
                        function empty(){}
                        
                        /**
                         * XHR Polling constructor.
                         *
                         * @param {Object} opts
                         * @api public
                         */
                        
                        function XHR(opts){
                          Polling.call(this, opts);
                        
                          if (global.location) {
                            var isSSL = &#x27;https:&#x27; == location.protocol;
                            var port = location.port;
                        
                            // some user agents have empty &#x60;location.port&#x60;
                            if (!port) {
                              port = isSSL ? 443 : 80;
                            }
                        
                            this.xd = opts.hostname != global.location.hostname ||
                              port != opts.port;
                            this.xs = opts.secure != isSSL;
                          }
                        }
                        
                        /**
                         * Inherits from Polling.
                         */
                        
                        inherit(XHR, Polling);
                        
                        /**
                         * XHR supports binary
                         */
                        
                        XHR.prototype.supportsBinary = true;
                        
                        /**
                         * Creates a request.
                         *
                         * @param {String} method
                         * @api private
                         */
                        
                        XHR.prototype.request = function(opts){
                          opts = opts || {};
                          opts.uri = this.uri();
                          opts.xd = this.xd;
                          opts.xs = this.xs;
                          opts.agent = this.agent || false;
                          opts.supportsBinary = this.supportsBinary;
                          opts.enablesXDR = this.enablesXDR;
                          return new Request(opts);
                        };
                        
                        /**
                         * Sends data.
                         *
                         * @param {String} data to send.
                         * @param {Function} called upon flush.
                         * @api private
                         */
                        
                        XHR.prototype.doWrite = function(data, fn){
                          var isBinary = typeof data !== &#x27;string&#x27; &amp;&amp; data !== undefined;
                          var req = this.request({ method: &#x27;POST&#x27;, data: data, isBinary: isBinary });
                          var self = this;
                          req.on(&#x27;success&#x27;, fn);
                          req.on(&#x27;error&#x27;, function(err){
                            self.onError(&#x27;xhr post error&#x27;, err);
                          });
                          this.sendXhr = req;
                        };
                        
                        /**
                         * Starts a poll cycle.
                         *
                         * @api private
                         */
                        
                        XHR.prototype.doPoll = function(){
                          debug(&#x27;xhr poll&#x27;);
                          var req = this.request();
                          var self = this;
                          req.on(&#x27;data&#x27;, function(data){
                            self.onData(data);
                          });
                          req.on(&#x27;error&#x27;, function(err){
                            self.onError(&#x27;xhr poll error&#x27;, err);
                          });
                          this.pollXhr = req;
                        };
                        
                        /**
                         * Request constructor
                         *
                         * @param {Object} options
                         * @api public
                         */
                        
                        function Request(opts){
                          this.method = opts.method || &#x27;GET&#x27;;
                          this.uri = opts.uri;
                          this.xd = !!opts.xd;
                          this.xs = !!opts.xs;
                          this.async = false !== opts.async;
                          this.data = undefined != opts.data ? opts.data : null;
                          this.agent = opts.agent;
                          this.isBinary = opts.isBinary;
                          this.supportsBinary = opts.supportsBinary;
                          this.enablesXDR = opts.enablesXDR;
                          this.create();
                        }
                        
                        /**
                         * Mix in &#x60;Emitter&#x60;.
                         */
                        
                        Emitter(Request.prototype);
                        
                        /**
                         * Creates the XHR object and sends the request.
                         *
                         * @api private
                         */
                        
                        Request.prototype.create = function(){
                          var xhr = this.xhr = new XMLHttpRequest({ agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR });
                          var self = this;
                        
                          try {
                            debug(&#x27;xhr open %s: %s&#x27;, this.method, this.uri);
                            xhr.open(this.method, this.uri, this.async);
                            if (this.supportsBinary) {
                              // This has to be done after open because Firefox is stupid
                              // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
                              xhr.responseType = &#x27;arraybuffer&#x27;;
                            }
                        
                            if (&#x27;POST&#x27; == this.method) {
                              try {
                                if (this.isBinary) {
                                  xhr.setRequestHeader(&#x27;Content-type&#x27;, &#x27;application/octet-stream&#x27;);
                                } else {
                                  xhr.setRequestHeader(&#x27;Content-type&#x27;, &#x27;text/plain;charset=UTF-8&#x27;);
                                }
                              } catch (e) {}
                            }
                        
                            // ie6 check
                            if (&#x27;withCredentials&#x27; in xhr) {
                              xhr.withCredentials = true;
                            }
                        
                            if (this.hasXDR()) {
                              xhr.onload = function(){
                                self.onLoad();
                              };
                              xhr.onerror = function(){
                                self.onError(xhr.responseText);
                              };
                            } else {
                              xhr.onreadystatechange = function(){
                                if (4 != xhr.readyState) return;
                                if (200 == xhr.status || 1223 == xhr.status) {
                                  self.onLoad();
                                } else {
                                  // make sure the &#x60;error&#x60; event handler that&#x27;s user-set
                                  // does not throw in the same tick and gets caught here
                                  setTimeout(function(){
                                    self.onError(xhr.status);
                                  }, 0);
                                }
                              };
                            }
                        
                            debug(&#x27;xhr data %s&#x27;, this.data);
                            xhr.send(this.data);
                          } catch (e) {
                            // Need to defer since .create() is called directly fhrom the constructor
                            // and thus the &#x27;error&#x27; event can only be only bound *after* this exception
                            // occurs.  Therefore, also, we cannot throw here at all.
                            setTimeout(function() {
                              self.onError(e);
                            }, 0);
                            return;
                          }
                        
                          if (global.document) {
                            this.index = Request.requestsCount++;
                            Request.requests[this.index] = this;
                          }
                        };
                        
                        /**
                         * Called upon successful response.
                         *
                         * @api private
                         */
                        
                        Request.prototype.onSuccess = function(){
                          this.emit(&#x27;success&#x27;);
                          this.cleanup();
                        };
                        
                        /**
                         * Called if we have data.
                         *
                         * @api private
                         */
                        
                        Request.prototype.onData = function(data){
                          this.emit(&#x27;data&#x27;, data);
                          this.onSuccess();
                        };
                        
                        /**
                         * Called upon error.
                         *
                         * @api private
                         */
                        
                        Request.prototype.onError = function(err){
                          this.emit(&#x27;error&#x27;, err);
                          this.cleanup();
                        };
                        
                        /**
                         * Cleans up house.
                         *
                         * @api private
                         */
                        
                        Request.prototype.cleanup = function(){
                          if (&#x27;undefined&#x27; == typeof this.xhr || null === this.xhr) {
                            return;
                          }
                          // xmlhttprequest
                          if (this.hasXDR()) {
                            this.xhr.onload = this.xhr.onerror = empty;
                          } else {
                            this.xhr.onreadystatechange = empty;
                          }
                        
                          try {
                            this.xhr.abort();
                          } catch(e) {}
                        
                          if (global.document) {
                            delete Request.requests[this.index];
                          }
                        
                          this.xhr = null;
                        };
                        
                        /**
                         * Called upon load.
                         *
                         * @api private
                         */
                        
                        Request.prototype.onLoad = function(){
                          var data;
                          try {
                            var contentType;
                            try {
                              contentType = this.xhr.getResponseHeader(&#x27;Content-Type&#x27;).split(&#x27;;&#x27;)[0];
                            } catch (e) {}
                            if (contentType === &#x27;application/octet-stream&#x27;) {
                              data = this.xhr.response;
                            } else {
                              if (!this.supportsBinary) {
                                data = this.xhr.responseText;
                              } else {
                                data = &#x27;ok&#x27;;
                              }
                            }
                          } catch (e) {
                            this.onError(e);
                          }
                          if (null != data) {
                            this.onData(data);
                          }
                        };
                        
                        /**
                         * Check if it has XDomainRequest.
                         *
                         * @api private
                         */
                        
                        Request.prototype.hasXDR = function(){
                          return &#x27;undefined&#x27; !== typeof global.XDomainRequest &amp;&amp; !this.xs &amp;&amp; this.enablesXDR;
                        };
                        
                        /**
                         * Aborts the request.
                         *
                         * @api public
                         */
                        
                        Request.prototype.abort = function(){
                          this.cleanup();
                        };
                        
                        /**
                         * Aborts pending requests when unloading the window. This is needed to prevent
                         * memory leaks (e.g. when using IE) and to ensure that no spurious error is
                         * emitted.
                         */
                        
                        if (global.document) {
                          Request.requestsCount = 0;
                          Request.requests = {};
                          if (global.attachEvent) {
                            global.attachEvent(&#x27;onunload&#x27;, unloadHandler);
                          } else if (global.addEventListener) {
                            global.addEventListener(&#x27;beforeunload&#x27;, unloadHandler);
                          }
                        }
                        
                        function unloadHandler() {
                          for (var i in Request.requests) {
                            if (Request.requests.hasOwnProperty(i)) {
                              Request.requests[i].abort();
                            }
                          }
                        }
                        
                        }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
                        },{&quot;./polling&quot;:17,&quot;component-emitter&quot;:8,&quot;component-inherit&quot;:20,&quot;debug&quot;:9,&quot;xmlhttprequest&quot;:19}],17:[function(_dereq_,module,exports){
                        /**
                         * Module dependencies.
                         */
                        
                        var Transport = _dereq_(&#x27;../transport&#x27;);
                        var parseqs = _dereq_(&#x27;parseqs&#x27;);
                        var parser = _dereq_(&#x27;engine.io-parser&#x27;);
                        var inherit = _dereq_(&#x27;component-inherit&#x27;);
                        var debug = _dereq_(&#x27;debug&#x27;)(&#x27;engine.io-client:polling&#x27;);
                        
                        /**
                         * Module exports.
                         */
                        
                        module.exports = Polling;
                        
                        /**
                         * Is XHR2 supported?
                         */
                        
                        var hasXHR2 = (function() {
                          var XMLHttpRequest = _dereq_(&#x27;xmlhttprequest&#x27;);
                          var xhr = new XMLHttpRequest({ xdomain: false });
                          return null != xhr.responseType;
                        })();
                        
                        /**
                         * Polling interface.
                         *
                         * @param {Object} opts
                         * @api private
                         */
                        
                        function Polling(opts){
                          var forceBase64 = (opts &amp;&amp; opts.forceBase64);
                          if (!hasXHR2 || forceBase64) {
                            this.supportsBinary = false;
                          }
                          Transport.call(this, opts);
                        }
                        
                        /**
                         * Inherits from Transport.
                         */
                        
                        inherit(Polling, Transport);
                        
                        /**
                         * Transport name.
                         */
                        
                        Polling.prototype.name = &#x27;polling&#x27;;
                        
                        /**
                         * Opens the socket (triggers polling). We write a PING message to determine
                         * when the transport is open.
                         *
                         * @api private
                         */
                        
                        Polling.prototype.doOpen = function(){
                          this.poll();
                        };
                        
                        /**
                         * Pauses polling.
                         *
                         * @param {Function} callback upon buffers are flushed and transport is paused
                         * @api private
                         */
                        
                        Polling.prototype.pause = function(onPause){
                          var pending = 0;
                          var self = this;
                        
                          this.readyState = &#x27;pausing&#x27;;
                        
                          function pause(){
                            debug(&#x27;paused&#x27;);
                            self.readyState = &#x27;paused&#x27;;
                            onPause();
                          }
                        
                          if (this.polling || !this.writable) {
                            var total = 0;
                        
                            if (this.polling) {
                              debug(&#x27;we are currently polling - waiting to pause&#x27;);
                              total++;
                              this.once(&#x27;pollComplete&#x27;, function(){
                                debug(&#x27;pre-pause polling complete&#x27;);
                                --total || pause();
                              });
                            }
                        
                            if (!this.writable) {
                              debug(&#x27;we are currently writing - waiting to pause&#x27;);
                              total++;
                              this.once(&#x27;drain&#x27;, function(){
                                debug(&#x27;pre-pause writing complete&#x27;);
                                --total || pause();
                              });
                            }
                          } else {
                            pause();
                          }
                        };
                        
                        /**
                         * Starts polling cycle.
                         *
                         * @api public
                         */
                        
                        Polling.prototype.poll = function(){
                          debug(&#x27;polling&#x27;);
                          this.polling = true;
                          this.doPoll();
                          this.emit(&#x27;poll&#x27;);
                        };
                        
                        /**
                         * Overloads onData to detect payloads.
                         *
                         * @api private
                         */
                        
                        Polling.prototype.onData = function(data){
                          var self = this;
                          debug(&#x27;polling got data %s&#x27;, data);
                          var callback = function(packet, index, total) {
                            // if its the first message we consider the transport open
                            if (&#x27;opening&#x27; == self.readyState) {
                              self.onOpen();
                            }
                        
                            // if its a close packet, we close the ongoing requests
                            if (&#x27;close&#x27; == packet.type) {
                              self.onClose();
                              return false;
                            }
                        
                            // otherwise bypass onData and handle the message
                            self.onPacket(packet);
                          };
                        
                          // decode payload
                          parser.decodePayload(data, this.socket.binaryType, callback);
                        
                          // if an event did not trigger closing
                          if (&#x27;closed&#x27; != this.readyState) {
                            // if we got data we&#x27;re not polling
                            this.polling = false;
                            this.emit(&#x27;pollComplete&#x27;);
                        
                            if (&#x27;open&#x27; == this.readyState) {
                              this.poll();
                            } else {
                              debug(&#x27;ignoring poll - transport state &quot;%s&quot;&#x27;, this.readyState);
                            }
                          }
                        };
                        
                        /**
                         * For polling, send a close packet.
                         *
                         * @api private
                         */
                        
                        Polling.prototype.doClose = function(){
                          var self = this;
                        
                          function close(){
                            debug(&#x27;writing close packet&#x27;);
                            self.write([{ type: &#x27;close&#x27; }]);
                          }
                        
                          if (&#x27;open&#x27; == this.readyState) {
                            debug(&#x27;transport open - closing&#x27;);
                            close();
                          } else {
                            // in case we&#x27;re trying to close while
                            // handshaking is in progress (GH-164)
                            debug(&#x27;transport not open - deferring close&#x27;);
                            this.once(&#x27;open&#x27;, close);
                          }
                        };
                        
                        /**
                         * Writes a packets payload.
                         *
                         * @param {Array} data packets
                         * @param {Function} drain callback
                         * @api private
                         */
                        
                        Polling.prototype.write = function(packets){
                          var self = this;
                          this.writable = false;
                          var callbackfn = function() {
                            self.writable = true;
                            self.emit(&#x27;drain&#x27;);
                          };
                        
                          var self = this;
                          parser.encodePayload(packets, this.supportsBinary, function(data) {
                            self.doWrite(data, callbackfn);
                          });
                        };
                        
                        /**
                         * Generates uri for connection.
                         *
                         * @api private
                         */
                        
                        Polling.prototype.uri = function(){
                          var query = this.query || {};
                          var schema = this.secure ? &#x27;https&#x27; : &#x27;http&#x27;;
                          var port = &#x27;&#x27;;
                        
                          // cache busting is forced
                          if (false !== this.timestampRequests) {
                            query[this.timestampParam] = +new Date + &#x27;-&#x27; + Transport.timestamps++;
                          }
                        
                          if (!this.supportsBinary &amp;&amp; !query.sid) {
                            query.b64 = 1;
                          }
                        
                          query = parseqs.encode(query);
                        
                          // avoid port if default for schema
                          if (this.port &amp;&amp; ((&#x27;https&#x27; == schema &amp;&amp; this.port != 443) ||
                             (&#x27;http&#x27; == schema &amp;&amp; this.port != 80))) {
                            port = &#x27;:&#x27; + this.port;
                          }
                        
                          // prepend ? to query
                          if (query.length) {
                            query = &#x27;?&#x27; + query;
                          }
                        
                          return schema + &#x27;://&#x27; + this.hostname + port + this.path + query;
                        };
                        
                        },{&quot;../transport&quot;:13,&quot;component-inherit&quot;:20,&quot;debug&quot;:9,&quot;engine.io-parser&quot;:21,&quot;parseqs&quot;:29,&quot;xmlhttprequest&quot;:19}],18:[function(_dereq_,module,exports){
                        /**
                         * Module dependencies.
                         */
                        
                        var Transport = _dereq_(&#x27;../transport&#x27;);
                        var parser = _dereq_(&#x27;engine.io-parser&#x27;);
                        var parseqs = _dereq_(&#x27;parseqs&#x27;);
                        var inherit = _dereq_(&#x27;component-inherit&#x27;);
                        var debug = _dereq_(&#x27;debug&#x27;)(&#x27;engine.io-client:websocket&#x27;);
                        
                        /**
                         * &#x60;ws&#x60; exposes a WebSocket-compatible interface in
                         * Node, or the &#x60;WebSocket&#x60; or &#x60;MozWebSocket&#x60; globals
                         * in the browser.
                         */
                        
                        var WebSocket = _dereq_(&#x27;ws&#x27;);
                        
                        /**
                         * Module exports.
                         */
                        
                        module.exports = WS;
                        
                        /**
                         * WebSocket transport constructor.
                         *
                         * @api {Object} connection options
                         * @api public
                         */
                        
                        function WS(opts){
                          var forceBase64 = (opts &amp;&amp; opts.forceBase64);
                          if (forceBase64) {
                            this.supportsBinary = false;
                          }
                          Transport.call(this, opts);
                        }
                        
                        /**
                         * Inherits from Transport.
                         */
                        
                        inherit(WS, Transport);
                        
                        /**
                         * Transport name.
                         *
                         * @api public
                         */
                        
                        WS.prototype.name = &#x27;websocket&#x27;;
                        
                        /*
                         * WebSockets support binary
                         */
                        
                        WS.prototype.supportsBinary = true;
                        
                        /**
                         * Opens socket.
                         *
                         * @api private
                         */
                        
                        WS.prototype.doOpen = function(){
                          if (!this.check()) {
                            // let probe timeout
                            return;
                          }
                        
                          var self = this;
                          var uri = this.uri();
                          var protocols = void(0);
                          var opts = { agent: this.agent };
                        
                          this.ws = new WebSocket(uri, protocols, opts);
                        
                          if (this.ws.binaryType === undefined) {
                            this.supportsBinary = false;
                          }
                        
                          this.ws.binaryType = &#x27;arraybuffer&#x27;;
                          this.addEventListeners();
                        };
                        
                        /**
                         * Adds event listeners to the socket
                         *
                         * @api private
                         */
                        
                        WS.prototype.addEventListeners = function(){
                          var self = this;
                        
                          this.ws.onopen = function(){
                            self.onOpen();
                          };
                          this.ws.onclose = function(){
                            self.onClose();
                          };
                          this.ws.onmessage = function(ev){
                            self.onData(ev.data);
                          };
                          this.ws.onerror = function(e){
                            self.onError(&#x27;websocket error&#x27;, e);
                          };
                        };
                        
                        /**
                         * Override &#x60;onData&#x60; to use a timer on iOS.
                         * See: https://gist.github.com/mloughran/2052006
                         *
                         * @api private
                         */
                        
                        if (&#x27;undefined&#x27; != typeof navigator
                          &amp;&amp; /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
                          WS.prototype.onData = function(data){
                            var self = this;
                            setTimeout(function(){
                              Transport.prototype.onData.call(self, data);
                            }, 0);
                          };
                        }
                        
                        /**
                         * Writes data to socket.
                         *
                         * @param {Array} array of packets.
                         * @api private
                         */
                        
                        WS.prototype.write = function(packets){
                          var self = this;
                          this.writable = false;
                          // encodePacket efficient as it uses WS framing
                          // no need for encodePayload
                          for (var i = 0, l = packets.length; i &lt; l; i++) {
                            parser.encodePacket(packets[i], this.supportsBinary, function(data) {
                              //Sometimes the websocket has already been closed but the browser didn&#x27;t
                              //have a chance of informing us about it yet, in that case send will
                              //throw an error
                              try {
                                self.ws.send(data);
                              } catch (e){
                                debug(&#x27;websocket closed before onclose event&#x27;);
                              }
                            });
                          }
                        
                          function ondrain() {
                            self.writable = true;
                            self.emit(&#x27;drain&#x27;);
                          }
                          // fake drain
                          // defer to next tick to allow Socket to clear writeBuffer
                          setTimeout(ondrain, 0);
                        };
                        
                        /**
                         * Called upon close
                         *
                         * @api private
                         */
                        
                        WS.prototype.onClose = function(){
                          Transport.prototype.onClose.call(this);
                        };
                        
                        /**
                         * Closes socket.
                         *
                         * @api private
                         */
                        
                        WS.prototype.doClose = function(){
                          if (typeof this.ws !== &#x27;undefined&#x27;) {
                            this.ws.close();
                          }
                        };
                        
                        /**
                         * Generates uri for connection.
                         *
                         * @api private
                         */
                        
                        WS.prototype.uri = function(){
                          var query = this.query || {};
                          var schema = this.secure ? &#x27;wss&#x27; : &#x27;ws&#x27;;
                          var port = &#x27;&#x27;;
                        
                          // avoid port if default for schema
                          if (this.port &amp;&amp; ((&#x27;wss&#x27; == schema &amp;&amp; this.port != 443)
                            || (&#x27;ws&#x27; == schema &amp;&amp; this.port != 80))) {
                            port = &#x27;:&#x27; + this.port;
                          }
                        
                          // append timestamp to URI
                          if (this.timestampRequests) {
                            query[this.timestampParam] = +new Date;
                          }
                        
                          // communicate binary support capabilities
                          if (!this.supportsBinary) {
                            query.b64 = 1;
                          }
                        
                          query = parseqs.encode(query);
                        
                          // prepend ? to query
                          if (query.length) {
                            query = &#x27;?&#x27; + query;
                          }
                        
                          return schema + &#x27;://&#x27; + this.hostname + port + this.path + query;
                        };
                        
                        /**
                         * Feature detection for WebSocket.
                         *
                         * @return {Boolean} whether this transport is available.
                         * @api public
                         */
                        
                        WS.prototype.check = function(){
                          return !!WebSocket &amp;&amp; !(&#x27;__initialize&#x27; in WebSocket &amp;&amp; this.name === WS.prototype.name);
                        };
                        
                        },{&quot;../transport&quot;:13,&quot;component-inherit&quot;:20,&quot;debug&quot;:9,&quot;engine.io-parser&quot;:21,&quot;parseqs&quot;:29,&quot;ws&quot;:31}],19:[function(_dereq_,module,exports){
                        // browser shim for xmlhttprequest module
                        var hasCORS = _dereq_(&#x27;has-cors&#x27;);
                        
                        module.exports = function(opts) {
                          var xdomain = opts.xdomain;
                        
                          // scheme must be same when usign XDomainRequest
                          // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
                          var xscheme = opts.xscheme;
                        
                          // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
                          // https://github.com/Automattic/engine.io-client/pull/217
                          var enablesXDR = opts.enablesXDR;
                        
                          // XMLHttpRequest can be disabled on IE
                          try {
                            if (&#x27;undefined&#x27; != typeof XMLHttpRequest &amp;&amp; (!xdomain || hasCORS)) {
                              return new XMLHttpRequest();
                            }
                          } catch (e) { }
                        
                          // Use XDomainRequest for IE8 if enablesXDR is true
                          // because loading bar keeps flashing when using jsonp-polling
                          // https://github.com/yujiosaka/socke.io-ie8-loading-example
                          try {
                            if (&#x27;undefined&#x27; != typeof XDomainRequest &amp;&amp; !xscheme &amp;&amp; enablesXDR) {
                              return new XDomainRequest();
                            }
                          } catch (e) { }
                        
                          if (!xdomain) {
                            try {
                              return new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;);
                            } catch(e) { }
                          }
                        }
                        
                        },{&quot;has-cors&quot;:34}],20:[function(_dereq_,module,exports){
                        
                        module.exports = function(a, b){
                          var fn = function(){};
                          fn.prototype = b.prototype;
                          a.prototype = new fn;
                          a.prototype.constructor = a;
                        };
                        },{}],21:[function(_dereq_,module,exports){
                        (function (global){
                        /**
                         * Module dependencies.
                         */
                        
                        var keys = _dereq_(&#x27;./keys&#x27;);
                        var sliceBuffer = _dereq_(&#x27;arraybuffer.slice&#x27;);
                        var base64encoder = _dereq_(&#x27;base64-arraybuffer&#x27;);
                        var after = _dereq_(&#x27;after&#x27;);
                        var utf8 = _dereq_(&#x27;utf8&#x27;);
                        
                        /**
                         * Check if we are running an android browser. That requires us to use
                         * ArrayBuffer with polling transports...
                         *
                         * http://ghinda.net/jpeg-blob-ajax-android/
                         */
                        
                        var isAndroid = navigator.userAgent.match(/Android/i);
                        
                        /**
                         * Current protocol version.
                         */
                        
                        exports.protocol = 3;
                        
                        /**
                         * Packet types.
                         */
                        
                        var packets = exports.packets = {
                            open:     0    // non-ws
                          , close:    1    // non-ws
                          , ping:     2
                          , pong:     3
                          , message:  4
                          , upgrade:  5
                          , noop:     6
                        };
                        
                        var packetslist = keys(packets);
                        
                        /**
                         * Premade error packet.
                         */
                        
                        var err = { type: &#x27;error&#x27;, data: &#x27;parser error&#x27; };
                        
                        /**
                         * Create a blob api even for blob builder when vendor prefixes exist
                         */
                        
                        var Blob = _dereq_(&#x27;blob&#x27;);
                        
                        /**
                         * Encodes a packet.
                         *
                         *     &lt;packet type id&gt; [ &lt;data&gt; ]
                         *
                         * Example:
                         *
                         *     5hello world
                         *     3
                         *     4
                         *
                         * Binary is encoded in an identical principle
                         *
                         * @api private
                         */
                        
                        exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
                          if (&#x27;function&#x27; == typeof supportsBinary) {
                            callback = supportsBinary;
                            supportsBinary = false;
                          }
                        
                          if (&#x27;function&#x27; == typeof utf8encode) {
                            callback = utf8encode;
                            utf8encode = null;
                          }
                        
                          var data = (packet.data === undefined)
                            ? undefined
                            : packet.data.buffer || packet.data;
                        
                          if (global.ArrayBuffer &amp;&amp; data instanceof ArrayBuffer) {
                            return encodeArrayBuffer(packet, supportsBinary, callback);
                          } else if (Blob &amp;&amp; data instanceof global.Blob) {
                            return encodeBlob(packet, supportsBinary, callback);
                          }
                        
                          // Sending data as a utf-8 string
                          var encoded = packets[packet.type];
                        
                          // data fragment is optional
                          if (undefined !== packet.data) {
                            encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
                          }
                        
                          return callback(&#x27;&#x27; + encoded);
                        
                        };
                        
                        /**
                         * Encode packet helpers for binary types
                         */
                        
                        function encodeArrayBuffer(packet, supportsBinary, callback) {
                          if (!supportsBinary) {
                            return exports.encodeBase64Packet(packet, callback);
                          }
                        
                          var data = packet.data;
                          var contentArray = new Uint8Array(data);
                          var resultBuffer = new Uint8Array(1 + data.byteLength);
                        
                          resultBuffer[0] = packets[packet.type];
                          for (var i = 0; i &lt; contentArray.length; i++) {
                            resultBuffer[i+1] = contentArray[i];
                          }
                        
                          return callback(resultBuffer.buffer);
                        }
                        
                        function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
                          if (!supportsBinary) {
                            return exports.encodeBase64Packet(packet, callback);
                          }
                        
                          var fr = new FileReader();
                          fr.onload = function() {
                            packet.data = fr.result;
                            exports.encodePacket(packet, supportsBinary, true, callback);
                          };
                          return fr.readAsArrayBuffer(packet.data);
                        }
                        
                        function encodeBlob(packet, supportsBinary, callback) {
                          if (!supportsBinary) {
                            return exports.encodeBase64Packet(packet, callback);
                          }
                        
                          if (isAndroid) {
                            return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
                          }
                        
                          var length = new Uint8Array(1);
                          length[0] = packets[packet.type];
                          var blob = new Blob([length.buffer, packet.data]);
                        
                          return callback(blob);
                        }
                        
                        /**
                         * Encodes a packet with binary data in a base64 string
                         *
                         * @param {Object} packet, has &#x60;type&#x60; and &#x60;data&#x60;
                         * @return {String} base64 encoded message
                         */
                        
                        exports.encodeBase64Packet = function(packet, callback) {
                          var message = &#x27;b&#x27; + exports.packets[packet.type];
                          if (Blob &amp;&amp; packet.data instanceof Blob) {
                            var fr = new FileReader();
                            fr.onload = function() {
                              var b64 = fr.result.split(&#x27;,&#x27;)[1];
                              callback(message + b64);
                            };
                            return fr.readAsDataURL(packet.data);
                          }
                        
                          var b64data;
                          try {
                            b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
                          } catch (e) {
                            // iPhone Safari doesn&#x27;t let you apply with typed arrays
                            var typed = new Uint8Array(packet.data);
                            var basic = new Array(typed.length);
                            for (var i = 0; i &lt; typed.length; i++) {
                              basic[i] = typed[i];
                            }
                            b64data = String.fromCharCode.apply(null, basic);
                          }
                          message += global.btoa(b64data);
                          return callback(message);
                        };
                        
                        /**
                         * Decodes a packet. Changes format to Blob if requested.
                         *
                         * @return {Object} with &#x60;type&#x60; and &#x60;data&#x60; (if any)
                         * @api private
                         */
                        
                        exports.decodePacket = function (data, binaryType, utf8decode) {
                          // String data
                          if (typeof data == &#x27;string&#x27; || data === undefined) {
                            if (data.charAt(0) == &#x27;b&#x27;) {
                              return exports.decodeBase64Packet(data.substr(1), binaryType);
                            }
                        
                            if (utf8decode) {
                              try {
                                data = utf8.decode(data);
                              } catch (e) {
                                return err;
                              }
                            }
                            var type = data.charAt(0);
                        
                            if (Number(type) != type || !packetslist[type]) {
                              return err;
                            }
                        
                            if (data.length &gt; 1) {
                              return { type: packetslist[type], data: data.substring(1) };
                            } else {
                              return { type: packetslist[type] };
                            }
                          }
                        
                          var asArray = new Uint8Array(data);
                          var type = asArray[0];
                          var rest = sliceBuffer(data, 1);
                          if (Blob &amp;&amp; binaryType === &#x27;blob&#x27;) {
                            rest = new Blob([rest]);
                          }
                          return { type: packetslist[type], data: rest };
                        };
                        
                        /**
                         * Decodes a packet encoded in a base64 string
                         *
                         * @param {String} base64 encoded message
                         * @return {Object} with &#x60;type&#x60; and &#x60;data&#x60; (if any)
                         */
                        
                        exports.decodeBase64Packet = function(msg, binaryType) {
                          var type = packetslist[msg.charAt(0)];
                          if (!global.ArrayBuffer) {
                            return { type: type, data: { base64: true, data: msg.substr(1) } };
                          }
                        
                          var data = base64encoder.decode(msg.substr(1));
                        
                          if (binaryType === &#x27;blob&#x27; &amp;&amp; Blob) {
                            data = new Blob([data]);
                          }
                        
                          return { type: type, data: data };
                        };
                        
                        /**
                         * Encodes multiple messages (payload).
                         *
                         *     &lt;length&gt;:data
                         *
                         * Example:
                         *
                         *     11:hello world2:hi
                         *
                         * If any contents are binary, they will be encoded as base64 strings. Base64
                         * encoded strings are marked with a b before the length specifier
                         *
                         * @param {Array} packets
                         * @api private
                         */
                        
                        exports.encodePayload = function (packets, supportsBinary, callback) {
                          if (typeof supportsBinary == &#x27;function&#x27;) {
                            callback = supportsBinary;
                            supportsBinary = null;
                          }
                        
                          if (supportsBinary) {
                            if (Blob &amp;&amp; !isAndroid) {
                              return exports.encodePayloadAsBlob(packets, callback);
                            }
                        
                            return exports.encodePayloadAsArrayBuffer(packets, callback);
                          }
                        
                          if (!packets.length) {
                            return callback(&#x27;0:&#x27;);
                          }
                        
                          function setLengthHeader(message) {
                            return message.length + &#x27;:&#x27; + message;
                          }
                        
                          function encodeOne(packet, doneCallback) {
                            exports.encodePacket(packet, supportsBinary, true, function(message) {
                              doneCallback(null, setLengthHeader(message));
                            });
                          }
                        
                          map(packets, encodeOne, function(err, results) {
                            return callback(results.join(&#x27;&#x27;));
                          });
                        };
                        
                        /**
                         * Async array map using after
                         */
                        
                        function map(ary, each, done) {
                          var result = new Array(ary.length);
                          var next = after(ary.length, done);
                        
                          var eachWithIndex = function(i, el, cb) {
                            each(el, function(error, msg) {
                              result[i] = msg;
                              cb(error, result);
                            });
                          };
                        
                          for (var i = 0; i &lt; ary.length; i++) {
                            eachWithIndex(i, ary[i], next);
                          }
                        }
                        
                        /*
                         * Decodes data when a payload is maybe expected. Possible binary contents are
                         * decoded from their base64 representation
                         *
                         * @param {String} data, callback method
                         * @api public
                         */
                        
                        exports.decodePayload = function (data, binaryType, callback) {
                          if (typeof data != &#x27;string&#x27;) {
                            return exports.decodePayloadAsBinary(data, binaryType, callback);
                          }
                        
                          if (typeof binaryType === &#x27;function&#x27;) {
                            callback = binaryType;
                            binaryType = null;
                          }
                        
                          var packet;
                          if (data == &#x27;&#x27;) {
                            // parser error - ignoring payload
                            return callback(err, 0, 1);
                          }
                        
                          var length = &#x27;&#x27;
                            , n, msg;
                        
                          for (var i = 0, l = data.length; i &lt; l; i++) {
                            var chr = data.charAt(i);
                        
                            if (&#x27;:&#x27; != chr) {
                              length += chr;
                            } else {
                              if (&#x27;&#x27; == length || (length != (n = Number(length)))) {
                                // parser error - ignoring payload
                                return callback(err, 0, 1);
                              }
                        
                              msg = data.substr(i + 1, n);
                        
                              if (length != msg.length) {
                                // parser error - ignoring payload
                                return callback(err, 0, 1);
                              }
                        
                              if (msg.length) {
                                packet = exports.decodePacket(msg, binaryType, true);
                        
                                if (err.type == packet.type &amp;&amp; err.data == packet.data) {
                                  // parser error in individual packet - ignoring payload
                                  return callback(err, 0, 1);
                                }
                        
                                var ret = callback(packet, i + n, l);
                                if (false === ret) return;
                              }
                        
                              // advance cursor
                              i += n;
                              length = &#x27;&#x27;;
                            }
                          }
                        
                          if (length != &#x27;&#x27;) {
                            // parser error - ignoring payload
                            return callback(err, 0, 1);
                          }
                        
                        };
                        
                        /**
                         * Encodes multiple messages (payload) as binary.
                         *
                         * &lt;1 = binary, 0 = string&gt;&lt;number from 0-9&gt;&lt;number from 0-9&gt;[...]&lt;number
                         * 255&gt;&lt;data&gt;
                         *
                         * Example:
                         * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
                         *
                         * @param {Array} packets
                         * @return {ArrayBuffer} encoded payload
                         * @api private
                         */
                        
                        exports.encodePayloadAsArrayBuffer = function(packets, callback) {
                          if (!packets.length) {
                            return callback(new ArrayBuffer(0));
                          }
                        
                          function encodeOne(packet, doneCallback) {
                            exports.encodePacket(packet, true, true, function(data) {
                              return doneCallback(null, data);
                            });
                          }
                        
                          map(packets, encodeOne, function(err, encodedPackets) {
                            var totalLength = encodedPackets.reduce(function(acc, p) {
                              var len;
                              if (typeof p === &#x27;string&#x27;){
                                len = p.length;
                              } else {
                                len = p.byteLength;
                              }
                              return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
                            }, 0);
                        
                            var resultArray = new Uint8Array(totalLength);
                        
                            var bufferIndex = 0;
                            encodedPackets.forEach(function(p) {
                              var isString = typeof p === &#x27;string&#x27;;
                              var ab = p;
                              if (isString) {
                                var view = new Uint8Array(p.length);
                                for (var i = 0; i &lt; p.length; i++) {
                                  view[i] = p.charCodeAt(i);
                                }
                                ab = view.buffer;
                              }
                        
                              if (isString) { // not true binary
                                resultArray[bufferIndex++] = 0;
                              } else { // true binary
                                resultArray[bufferIndex++] = 1;
                              }
                        
                              var lenStr = ab.byteLength.toString();
                              for (var i = 0; i &lt; lenStr.length; i++) {
                                resultArray[bufferIndex++] = parseInt(lenStr[i]);
                              }
                              resultArray[bufferIndex++] = 255;
                        
                              var view = new Uint8Array(ab);
                              for (var i = 0; i &lt; view.length; i++) {
                                resultArray[bufferIndex++] = view[i];
                              }
                            });
                        
                            return callback(resultArray.buffer);
                          });
                        };
                        
                        /**
                         * Encode as Blob
                         */
                        
                        exports.encodePayloadAsBlob = function(packets, callback) {
                          function encodeOne(packet, doneCallback) {
                            exports.encodePacket(packet, true, true, function(encoded) {
                              var binaryIdentifier = new Uint8Array(1);
                              binaryIdentifier[0] = 1;
                              if (typeof encoded === &#x27;string&#x27;) {
                                var view = new Uint8Array(encoded.length);
                                for (var i = 0; i &lt; encoded.length; i++) {
                                  view[i] = encoded.charCodeAt(i);
                                }
                                encoded = view.buffer;
                                binaryIdentifier[0] = 0;
                              }
                        
                              var len = (encoded instanceof ArrayBuffer)
                                ? encoded.byteLength
                                : encoded.size;
                        
                              var lenStr = len.toString();
                              var lengthAry = new Uint8Array(lenStr.length + 1);
                              for (var i = 0; i &lt; lenStr.length; i++) {
                                lengthAry[i] = parseInt(lenStr[i]);
                              }
                              lengthAry[lenStr.length] = 255;
                        
                              if (Blob) {
                                var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
                                doneCallback(null, blob);
                              }
                            });
                          }
                        
                          map(packets, encodeOne, function(err, results) {
                            return callback(new Blob(results));
                          });
                        };
                        
                        /*
                         * Decodes data when a payload is maybe expected. Strings are decoded by
                         * interpreting each byte as a key code for entries marked to start with 0. See
                         * description of encodePayloadAsBinary
                         *
                         * @param {ArrayBuffer} data, callback method
                         * @api public
                         */
                        
                        exports.decodePayloadAsBinary = function (data, binaryType, callback) {
                          if (typeof binaryType === &#x27;function&#x27;) {
                            callback = binaryType;
                            binaryType = null;
                          }
                        
                          var bufferTail = data;
                          var buffers = [];
                        
                          var numberTooLong = false;
                          while (bufferTail.byteLength &gt; 0) {
                            var tailArray = new Uint8Array(bufferTail);
                            var isString = tailArray[0] === 0;
                            var msgLength = &#x27;&#x27;;
                        
                            for (var i = 1; ; i++) {
                              if (tailArray[i] == 255) break;
                        
                              if (msgLength.length &gt; 310) {
                                numberTooLong = true;
                                break;
                              }
                        
                              msgLength += tailArray[i];
                            }
                        
                            if(numberTooLong) return callback(err, 0, 1);
                        
                            bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
                            msgLength = parseInt(msgLength);
                        
                            var msg = sliceBuffer(bufferTail, 0, msgLength);
                            if (isString) {
                              try {
                                msg = String.fromCharCode.apply(null, new Uint8Array(msg));
                              } catch (e) {
                                // iPhone Safari doesn&#x27;t let you apply to typed arrays
                                var typed = new Uint8Array(msg);
                                msg = &#x27;&#x27;;
                                for (var i = 0; i &lt; typed.length; i++) {
                                  msg += String.fromCharCode(typed[i]);
                                }
                              }
                            }
                        
                            buffers.push(msg);
                            bufferTail = sliceBuffer(bufferTail, msgLength);
                          }
                        
                          var total = buffers.length;
                          buffers.forEach(function(buffer, i) {
                            callback(exports.decodePacket(buffer, binaryType, true), i, total);
                          });
                        };
                        
                        }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
                        },{&quot;./keys&quot;:22,&quot;after&quot;:23,&quot;arraybuffer.slice&quot;:24,&quot;base64-arraybuffer&quot;:25,&quot;blob&quot;:26,&quot;utf8&quot;:27}],22:[function(_dereq_,module,exports){
                        
                        /**
                         * Gets the keys for an object.
                         *
                         * @return {Array} keys
                         * @api private
                         */
                        
                        module.exports = Object.keys || function keys (obj){
                          var arr = [];
                          var has = Object.prototype.hasOwnProperty;
                        
                          for (var i in obj) {
                            if (has.call(obj, i)) {
                              arr.push(i);
                            }
                          }
                          return arr;
                        };
                        
                        },{}],23:[function(_dereq_,module,exports){
                        module.exports = after
                        
                        function after(count, callback, err_cb) {
                            var bail = false
                            err_cb = err_cb || noop
                            proxy.count = count
                        
                            return (count === 0) ? callback() : proxy
                        
                            function proxy(err, result) {
                                if (proxy.count &lt;= 0) {
                                    throw new Error(&#x27;after called too many times&#x27;)
                                }
                                --proxy.count
                        
                                // after first error, rest are passed to err_cb
                                if (err) {
                                    bail = true
                                    callback(err)
                                    // future error callbacks will go to error handler
                                    callback = err_cb
                                } else if (proxy.count === 0 &amp;&amp; !bail) {
                                    callback(null, result)
                                }
                            }
                        }
                        
                        function noop() {}
                        
                        },{}],24:[function(_dereq_,module,exports){
                        /**
                         * An abstraction for slicing an arraybuffer even when
                         * ArrayBuffer.prototype.slice is not supported
                         *
                         * @api public
                         */
                        
                        module.exports = function(arraybuffer, start, end) {
                          var bytes = arraybuffer.byteLength;
                          start = start || 0;
                          end = end || bytes;
                        
                          if (arraybuffer.slice) { return arraybuffer.slice(start, end); }
                        
                          if (start &lt; 0) { start += bytes; }
                          if (end &lt; 0) { end += bytes; }
                          if (end &gt; bytes) { end = bytes; }
                        
                          if (start &gt;= bytes || start &gt;= end || bytes === 0) {
                            return new ArrayBuffer(0);
                          }
                        
                          var abv = new Uint8Array(arraybuffer);
                          var result = new Uint8Array(end - start);
                          for (var i = start, ii = 0; i &lt; end; i++, ii++) {
                            result[ii] = abv[i];
                          }
                          return result.buffer;
                        };
                        
                        },{}],25:[function(_dereq_,module,exports){
                        /*
                         * base64-arraybuffer
                         * https://github.com/niklasvh/base64-arraybuffer
                         *
                         * Copyright (c) 2012 Niklas von Hertzen
                         * Licensed under the MIT license.
                         */
                        (function(chars){
                          &quot;use strict&quot;;
                        
                          exports.encode = function(arraybuffer) {
                            var bytes = new Uint8Array(arraybuffer),
                            i, len = bytes.length, base64 = &quot;&quot;;
                        
                            for (i = 0; i &lt; len; i+=3) {
                              base64 += chars[bytes[i] &gt;&gt; 2];
                              base64 += chars[((bytes[i] &amp; 3) &lt;&lt; 4) | (bytes[i + 1] &gt;&gt; 4)];
                              base64 += chars[((bytes[i + 1] &amp; 15) &lt;&lt; 2) | (bytes[i + 2] &gt;&gt; 6)];
                              base64 += chars[bytes[i + 2] &amp; 63];
                            }
                        
                            if ((len % 3) === 2) {
                              base64 = base64.substring(0, base64.length - 1) + &quot;=&quot;;
                            } else if (len % 3 === 1) {
                              base64 = base64.substring(0, base64.length - 2) + &quot;==&quot;;
                            }
                        
                            return base64;
                          };
                        
                          exports.decode =  function(base64) {
                            var bufferLength = base64.length * 0.75,
                            len = base64.length, i, p = 0,
                            encoded1, encoded2, encoded3, encoded4;
                        
                            if (base64[base64.length - 1] === &quot;=&quot;) {
                              bufferLength--;
                              if (base64[base64.length - 2] === &quot;=&quot;) {
                                bufferLength--;
                              }
                            }
                        
                            var arraybuffer = new ArrayBuffer(bufferLength),
                            bytes = new Uint8Array(arraybuffer);
                        
                            for (i = 0; i &lt; len; i+=4) {
                              encoded1 = chars.indexOf(base64[i]);
                              encoded2 = chars.indexOf(base64[i+1]);
                              encoded3 = chars.indexOf(base64[i+2]);
                              encoded4 = chars.indexOf(base64[i+3]);
                        
                              bytes[p++] = (encoded1 &lt;&lt; 2) | (encoded2 &gt;&gt; 4);
                              bytes[p++] = ((encoded2 &amp; 15) &lt;&lt; 4) | (encoded3 &gt;&gt; 2);
                              bytes[p++] = ((encoded3 &amp; 3) &lt;&lt; 6) | (encoded4 &amp; 63);
                            }
                        
                            return arraybuffer;
                          };
                        })(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;);
                        
                        },{}],26:[function(_dereq_,module,exports){
                        (function (global){
                        /**
                         * Create a blob builder even when vendor prefixes exist
                         */
                        
                        var BlobBuilder = global.BlobBuilder
                          || global.WebKitBlobBuilder
                          || global.MSBlobBuilder
                          || global.MozBlobBuilder;
                        
                        /**
                         * Check if Blob constructor is supported
                         */
                        
                        var blobSupported = (function() {
                          try {
                            var b = new Blob([&#x27;hi&#x27;]);
                            return b.size == 2;
                          } catch(e) {
                            return false;
                          }
                        })();
                        
                        /**
                         * Check if BlobBuilder is supported
                         */
                        
                        var blobBuilderSupported = BlobBuilder
                          &amp;&amp; BlobBuilder.prototype.append
                          &amp;&amp; BlobBuilder.prototype.getBlob;
                        
                        function BlobBuilderConstructor(ary, options) {
                          options = options || {};
                        
                          var bb = new BlobBuilder();
                          for (var i = 0; i &lt; ary.length; i++) {
                            bb.append(ary[i]);
                          }
                          return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
                        };
                        
                        module.exports = (function() {
                          if (blobSupported) {
                            return global.Blob;
                          } else if (blobBuilderSupported) {
                            return BlobBuilderConstructor;
                          } else {
                            return undefined;
                          }
                        })();
                        
                        }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
                        },{}],27:[function(_dereq_,module,exports){
                        (function (global){
                        /*! http://mths.be/utf8js v2.0.0 by @mathias */
                        ;(function(root) {
                        
                        	// Detect free variables &#x60;exports&#x60;
                        	var freeExports = typeof exports == &#x27;object&#x27; &amp;&amp; exports;
                        
                        	// Detect free variable &#x60;module&#x60;
                        	var freeModule = typeof module == &#x27;object&#x27; &amp;&amp; module &amp;&amp;
                        		module.exports == freeExports &amp;&amp; module;
                        
                        	// Detect free variable &#x60;global&#x60;, from Node.js or Browserified code,
                        	// and use it as &#x60;root&#x60;
                        	var freeGlobal = typeof global == &#x27;object&#x27; &amp;&amp; global;
                        	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
                        		root = freeGlobal;
                        	}
                        
                        	/*--------------------------------------------------------------------------*/
                        
                        	var stringFromCharCode = String.fromCharCode;
                        
                        	// Taken from http://mths.be/punycode
                        	function ucs2decode(string) {
                        		var output = [];
                        		var counter = 0;
                        		var length = string.length;
                        		var value;
                        		var extra;
                        		while (counter &lt; length) {
                        			value = string.charCodeAt(counter++);
                        			if (value &gt;= 0xD800 &amp;&amp; value &lt;= 0xDBFF &amp;&amp; counter &lt; length) {
                        				// high surrogate, and there is a next character
                        				extra = string.charCodeAt(counter++);
                        				if ((extra &amp; 0xFC00) == 0xDC00) { // low surrogate
                        					output.push(((value &amp; 0x3FF) &lt;&lt; 10) + (extra &amp; 0x3FF) + 0x10000);
                        				} else {
                        					// unmatched surrogate; only append this code unit, in case the next
                        					// code unit is the high surrogate of a surrogate pair
                        					output.push(value);
                        					counter--;
                        				}
                        			} else {
                        				output.push(value);
                        			}
                        		}
                        		return output;
                        	}
                        
                        	// Taken from http://mths.be/punycode
                        	function ucs2encode(array) {
                        		var length = array.length;
                        		var index = -1;
                        		var value;
                        		var output = &#x27;&#x27;;
                        		while (++index &lt; length) {
                        			value = array[index];
                        			if (value &gt; 0xFFFF) {
                        				value -= 0x10000;
                        				output += stringFromCharCode(value &gt;&gt;&gt; 10 &amp; 0x3FF | 0xD800);
                        				value = 0xDC00 | value &amp; 0x3FF;
                        			}
                        			output += stringFromCharCode(value);
                        		}
                        		return output;
                        	}
                        
                        	/*--------------------------------------------------------------------------*/
                        
                        	function createByte(codePoint, shift) {
                        		return stringFromCharCode(((codePoint &gt;&gt; shift) &amp; 0x3F) | 0x80);
                        	}
                        
                        	function encodeCodePoint(codePoint) {
                        		if ((codePoint &amp; 0xFFFFFF80) == 0) { // 1-byte sequence
                        			return stringFromCharCode(codePoint);
                        		}
                        		var symbol = &#x27;&#x27;;
                        		if ((codePoint &amp; 0xFFFFF800) == 0) { // 2-byte sequence
                        			symbol = stringFromCharCode(((codePoint &gt;&gt; 6) &amp; 0x1F) | 0xC0);
                        		}
                        		else if ((codePoint &amp; 0xFFFF0000) == 0) { // 3-byte sequence
                        			symbol = stringFromCharCode(((codePoint &gt;&gt; 12) &amp; 0x0F) | 0xE0);
                        			symbol += createByte(codePoint, 6);
                        		}
                        		else if ((codePoint &amp; 0xFFE00000) == 0) { // 4-byte sequence
                        			symbol = stringFromCharCode(((codePoint &gt;&gt; 18) &amp; 0x07) | 0xF0);
                        			symbol += createByte(codePoint, 12);
                        			symbol += createByte(codePoint, 6);
                        		}
                        		symbol += stringFromCharCode((codePoint &amp; 0x3F) | 0x80);
                        		return symbol;
                        	}
                        
                        	function utf8encode(string) {
                        		var codePoints = ucs2decode(string);
                        
                        		// console.log(JSON.stringify(codePoints.map(function(x) {
                        		// 	return &#x27;U+&#x27; + x.toString(16).toUpperCase();
                        		// })));
                        
                        		var length = codePoints.length;
                        		var index = -1;
                        		var codePoint;
                        		var byteString = &#x27;&#x27;;
                        		while (++index &lt; length) {
                        			codePoint = codePoints[index];
                        			byteString += encodeCodePoint(codePoint);
                        		}
                        		return byteString;
                        	}
                        
                        	/*--------------------------------------------------------------------------*/
                        
                        	function readContinuationByte() {
                        		if (byteIndex &gt;= byteCount) {
                        			throw Error(&#x27;Invalid byte index&#x27;);
                        		}
                        
                        		var continuationByte = byteArray[byteIndex] &amp; 0xFF;
                        		byteIndex++;
                        
                        		if ((continuationByte &amp; 0xC0) == 0x80) {
                        			return continuationByte &amp; 0x3F;
                        		}
                        
                        		// If we end up here, its not a continuation byte
                        		throw Error(&#x27;Invalid continuation byte&#x27;);
                        	}
                        
                        	function decodeSymbol() {
                        		var byte1;
                        		var byte2;
                        		var byte3;
                        		var byte4;
                        		var codePoint;
                        
                        		if (byteIndex &gt; byteCount) {
                        			throw Error(&#x27;Invalid byte index&#x27;);
                        		}
                        
                        		if (byteIndex == byteCount) {
                        			return false;
                        		}
                        
                        		// Read first byte
                        		byte1 = byteArray[byteIndex] &amp; 0xFF;
                        		byteIndex++;
                        
                        		// 1-byte sequence (no continuation bytes)
                        		if ((byte1 &amp; 0x80) == 0) {
                        			return byte1;
                        		}
                        
                        		// 2-byte sequence
                        		if ((byte1 &amp; 0xE0) == 0xC0) {
                        			var byte2 = readContinuationByte();
                        			codePoint = ((byte1 &amp; 0x1F) &lt;&lt; 6) | byte2;
                        			if (codePoint &gt;= 0x80) {
                        				return codePoint;
                        			} else {
                        				throw Error(&#x27;Invalid continuation byte&#x27;);
                        			}
                        		}
                        
                        		// 3-byte sequence (may include unpaired surrogates)
                        		if ((byte1 &amp; 0xF0) == 0xE0) {
                        			byte2 = readContinuationByte();
                        			byte3 = readContinuationByte();
                        			codePoint = ((byte1 &amp; 0x0F) &lt;&lt; 12) | (byte2 &lt;&lt; 6) | byte3;
                        			if (codePoint &gt;= 0x0800) {
                        				return codePoint;
                        			} else {
                        				throw Error(&#x27;Invalid continuation byte&#x27;);
                        			}
                        		}
                        
                        		// 4-byte sequence
                        		if ((byte1 &amp; 0xF8) == 0xF0) {
                        			byte2 = readContinuationByte();
                        			byte3 = readContinuationByte();
                        			byte4 = readContinuationByte();
                        			codePoint = ((byte1 &amp; 0x0F) &lt;&lt; 0x12) | (byte2 &lt;&lt; 0x0C) |
                        				(byte3 &lt;&lt; 0x06) | byte4;
                        			if (codePoint &gt;= 0x010000 &amp;&amp; codePoint &lt;= 0x10FFFF) {
                        				return codePoint;
                        			}
                        		}
                        
                        		throw Error(&#x27;Invalid UTF-8 detected&#x27;);
                        	}
                        
                        	var byteArray;
                        	var byteCount;
                        	var byteIndex;
                        	function utf8decode(byteString) {
                        		byteArray = ucs2decode(byteString);
                        		byteCount = byteArray.length;
                        		byteIndex = 0;
                        		var codePoints = [];
                        		var tmp;
                        		while ((tmp = decodeSymbol()) !== false) {
                        			codePoints.push(tmp);
                        		}
                        		return ucs2encode(codePoints);
                        	}
                        
                        	/*--------------------------------------------------------------------------*/
                        
                        	var utf8 = {
                        		&#x27;version&#x27;: &#x27;2.0.0&#x27;,
                        		&#x27;encode&#x27;: utf8encode,
                        		&#x27;decode&#x27;: utf8decode
                        	};
                        
                        	// Some AMD build optimizers, like r.js, check for specific condition patterns
                        	// like the following:
                        	if (
                        		typeof define == &#x27;function&#x27; &amp;&amp;
                        		typeof define.amd == &#x27;object&#x27; &amp;&amp;
                        		define.amd
                        	) {
                        		define(function() {
                        			return utf8;
                        		});
                        	}	else if (freeExports &amp;&amp; !freeExports.nodeType) {
                        		if (freeModule) { // in Node.js or RingoJS v0.8.0+
                        			freeModule.exports = utf8;
                        		} else { // in Narwhal or RingoJS v0.7.0-
                        			var object = {};
                        			var hasOwnProperty = object.hasOwnProperty;
                        			for (var key in utf8) {
                        				hasOwnProperty.call(utf8, key) &amp;&amp; (freeExports[key] = utf8[key]);
                        			}
                        		}
                        	} else { // in Rhino or a web browser
                        		root.utf8 = utf8;
                        	}
                        
                        }(this));
                        
                        }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
                        },{}],28:[function(_dereq_,module,exports){
                        (function (global){
                        /**
                         * JSON parse.
                         *
                         * @see Based on jQuery#parseJSON (MIT) and JSON2
                         * @api private
                         */
                        
                        var rvalidchars = /^[\],:{}\s]*$/;
                        var rvalidescape = /\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
                        var rvalidtokens = /&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
                        var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
                        var rtrimLeft = /^\s+/;
                        var rtrimRight = /\s+$/;
                        
                        module.exports = function parsejson(data) {
                          if (&#x27;string&#x27; != typeof data || !data) {
                            return null;
                          }
                        
                          data = data.replace(rtrimLeft, &#x27;&#x27;).replace(rtrimRight, &#x27;&#x27;);
                        
                          // Attempt to parse using the native JSON parser first
                          if (global.JSON &amp;&amp; JSON.parse) {
                            return JSON.parse(data);
                          }
                        
                          if (rvalidchars.test(data.replace(rvalidescape, &#x27;@&#x27;)
                              .replace(rvalidtokens, &#x27;]&#x27;)
                              .replace(rvalidbraces, &#x27;&#x27;))) {
                            return (new Function(&#x27;return &#x27; + data))();
                          }
                        };
                        }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
                        },{}],29:[function(_dereq_,module,exports){
                        /**
                         * Compiles a querystring
                         * Returns string representation of the object
                         *
                         * @param {Object}
                         * @api private
                         */
                        
                        exports.encode = function (obj) {
                          var str = &#x27;&#x27;;
                        
                          for (var i in obj) {
                            if (obj.hasOwnProperty(i)) {
                              if (str.length) str += &#x27;&amp;&#x27;;
                              str += encodeURIComponent(i) + &#x27;=&#x27; + encodeURIComponent(obj[i]);
                            }
                          }
                        
                          return str;
                        };
                        
                        /**
                         * Parses a simple querystring into an object
                         *
                         * @param {String} qs
                         * @api private
                         */
                        
                        exports.decode = function(qs){
                          var qry = {};
                          var pairs = qs.split(&#x27;&amp;&#x27;);
                          for (var i = 0, l = pairs.length; i &lt; l; i++) {
                            var pair = pairs[i].split(&#x27;=&#x27;);
                            qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
                          }
                          return qry;
                        };
                        
                        },{}],30:[function(_dereq_,module,exports){
                        /**
                         * Parses an URI
                         *
                         * @author Steven Levithan &lt;stevenlevithan.com&gt; (MIT license)
                         * @api private
                         */
                        
                        var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
                        
                        var parts = [
                            &#x27;source&#x27;, &#x27;protocol&#x27;, &#x27;authority&#x27;, &#x27;userInfo&#x27;, &#x27;user&#x27;, &#x27;password&#x27;, &#x27;host&#x27;, &#x27;port&#x27;, &#x27;relative&#x27;, &#x27;path&#x27;, &#x27;directory&#x27;, &#x27;file&#x27;, &#x27;query&#x27;, &#x27;anchor&#x27;
                        ];
                        
                        module.exports = function parseuri(str) {
                            var src = str,
                                b = str.indexOf(&#x27;[&#x27;),
                                e = str.indexOf(&#x27;]&#x27;);
                        
                            if (b != -1 &amp;&amp; e != -1) {
                                str = str.substring(0, b) + str.substring(b, e).replace(/:/g, &#x27;;&#x27;) + str.substring(e, str.length);
                            }
                        
                            var m = re.exec(str || &#x27;&#x27;),
                                uri = {},
                                i = 14;
                        
                            while (i--) {
                                uri[parts[i]] = m[i] || &#x27;&#x27;;
                            }
                        
                            if (b != -1 &amp;&amp; e != -1) {
                                uri.source = src;
                                uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, &#x27;:&#x27;);
                                uri.authority = uri.authority.replace(&#x27;[&#x27;, &#x27;&#x27;).replace(&#x27;]&#x27;, &#x27;&#x27;).replace(/;/g, &#x27;:&#x27;);
                                uri.ipv6uri = true;
                            }
                        
                            return uri;
                        };
                        
                        },{}],31:[function(_dereq_,module,exports){
                        
                        /**
                         * Module dependencies.
                         */
                        
                        var global = (function() { return this; })();
                        
                        /**
                         * WebSocket constructor.
                         */
                        
                        var WebSocket = global.WebSocket || global.MozWebSocket;
                        
                        /**
                         * Module exports.
                         */
                        
                        module.exports = WebSocket ? ws : null;
                        
                        /**
                         * WebSocket constructor.
                         *
                         * The third &#x60;opts&#x60; options object gets ignored in web browsers, since it&#x27;s
                         * non-standard, and throws a TypeError if passed to the constructor.
                         * See: https://github.com/einaros/ws/issues/227
                         *
                         * @param {String} uri
                         * @param {Array} protocols (optional)
                         * @param {Object) opts (optional)
                         * @api public
                         */
                        
                        function ws(uri, protocols, opts) {
                          var instance;
                          if (protocols) {
                            instance = new WebSocket(uri, protocols);
                          } else {
                            instance = new WebSocket(uri);
                          }
                          return instance;
                        }
                        
                        if (WebSocket) ws.prototype = WebSocket.prototype;
                        
                        },{}],32:[function(_dereq_,module,exports){
                        (function (global){
                        
                        /*
                         * Module requirements.
                         */
                        
                        var isArray = _dereq_(&#x27;isarray&#x27;);
                        
                        /**
                         * Module exports.
                         */
                        
                        module.exports = hasBinary;
                        
                        /**
                         * Checks for binary data.
                         *
                         * Right now only Buffer and ArrayBuffer are supported..
                         *
                         * @param {Object} anything
                         * @api public
                         */
                        
                        function hasBinary(data) {
                        
                          function _hasBinary(obj) {
                            if (!obj) return false;
                        
                            if ( (global.Buffer &amp;&amp; global.Buffer.isBuffer(obj)) ||
                                 (global.ArrayBuffer &amp;&amp; obj instanceof ArrayBuffer) ||
                                 (global.Blob &amp;&amp; obj instanceof Blob) ||
                                 (global.File &amp;&amp; obj instanceof File)
                                ) {
                              return true;
                            }
                        
                            if (isArray(obj)) {
                              for (var i = 0; i &lt; obj.length; i++) {
                                  if (_hasBinary(obj[i])) {
                                      return true;
                                  }
                              }
                            } else if (obj &amp;&amp; &#x27;object&#x27; == typeof obj) {
                              if (obj.toJSON) {
                                obj = obj.toJSON();
                              }
                        
                              for (var key in obj) {
                                if (obj.hasOwnProperty(key) &amp;&amp; _hasBinary(obj[key])) {
                                  return true;
                                }
                              }
                            }
                        
                            return false;
                          }
                        
                          return _hasBinary(data);
                        }
                        
                        }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
                        },{&quot;isarray&quot;:33}],33:[function(_dereq_,module,exports){
                        module.exports = Array.isArray || function (arr) {
                          return Object.prototype.toString.call(arr) == &#x27;[object Array]&#x27;;
                        };
                        
                        },{}],34:[function(_dereq_,module,exports){
                        
                        /**
                         * Module dependencies.
                         */
                        
                        var global = _dereq_(&#x27;global&#x27;);
                        
                        /**
                         * Module exports.
                         *
                         * Logic borrowed from Modernizr:
                         *
                         *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
                         */
                        
                        try {
                          module.exports = &#x27;XMLHttpRequest&#x27; in global &amp;&amp;
                            &#x27;withCredentials&#x27; in new global.XMLHttpRequest();
                        } catch (err) {
                          // if XMLHttp support is disabled in IE then it will throw
                          // when trying to create
                          module.exports = false;
                        }
                        
                        },{&quot;global&quot;:35}],35:[function(_dereq_,module,exports){
                        
                        /**
                         * Returns &#x60;this&#x60;. Execute this without a &quot;context&quot; (i.e. without it being
                         * attached to an object of the left-hand side), and &#x60;this&#x60; points to the
                         * &quot;global&quot; scope of the current JS execution.
                         */
                        
                        module.exports = (function () { return this; })();
                        
                        },{}],36:[function(_dereq_,module,exports){
                        
                        var indexOf = [].indexOf;
                        
                        module.exports = function(arr, obj){
                          if (indexOf) return arr.indexOf(obj);
                          for (var i = 0; i &lt; arr.length; ++i) {
                            if (arr[i] === obj) return i;
                          }
                          return -1;
                        };
                        },{}],37:[function(_dereq_,module,exports){
                        
                        /**
                         * HOP ref.
                         */
                        
                        var has = Object.prototype.hasOwnProperty;
                        
                        /**
                         * Return own keys in &#x60;obj&#x60;.
                         *
                         * @param {Object} obj
                         * @return {Array}
                         * @api public
                         */
                        
                        exports.keys = Object.keys || function(obj){
                          var keys = [];
                          for (var key in obj) {
                            if (has.call(obj, key)) {
                              keys.push(key);
                            }
                          }
                          return keys;
                        };
                        
                        /**
                         * Return own values in &#x60;obj&#x60;.
                         *
                         * @param {Object} obj
                         * @return {Array}
                         * @api public
                         */
                        
                        exports.values = function(obj){
                          var vals = [];
                          for (var key in obj) {
                            if (has.call(obj, key)) {
                              vals.push(obj[key]);
                            }
                          }
                          return vals;
                        };
                        
                        /**
                         * Merge &#x60;b&#x60; into &#x60;a&#x60;.
                         *
                         * @param {Object} a
                         * @param {Object} b
                         * @return {Object} a
                         * @api public
                         */
                        
                        exports.merge = function(a, b){
                          for (var key in b) {
                            if (has.call(b, key)) {
                              a[key] = b[key];
                            }
                          }
                          return a;
                        };
                        
                        /**
                         * Return length of &#x60;obj&#x60;.
                         *
                         * @param {Object} obj
                         * @return {Number}
                         * @api public
                         */
                        
                        exports.length = function(obj){
                          return exports.keys(obj).length;
                        };
                        
                        /**
                         * Check if &#x60;obj&#x60; is empty.
                         *
                         * @param {Object} obj
                         * @return {Boolean}
                         * @api public
                         */
                        
                        exports.isEmpty = function(obj){
                          return 0 == exports.length(obj);
                        };
                        },{}],38:[function(_dereq_,module,exports){
                        /**
                         * Parses an URI
                         *
                         * @author Steven Levithan &lt;stevenlevithan.com&gt; (MIT license)
                         * @api private
                         */
                        
                        var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
                        
                        var parts = [
                            &#x27;source&#x27;, &#x27;protocol&#x27;, &#x27;authority&#x27;, &#x27;userInfo&#x27;, &#x27;user&#x27;, &#x27;password&#x27;, &#x27;host&#x27;
                          , &#x27;port&#x27;, &#x27;relative&#x27;, &#x27;path&#x27;, &#x27;directory&#x27;, &#x27;file&#x27;, &#x27;query&#x27;, &#x27;anchor&#x27;
                        ];
                        
                        module.exports = function parseuri(str) {
                          var m = re.exec(str || &#x27;&#x27;)
                            , uri = {}
                            , i = 14;
                        
                          while (i--) {
                            uri[parts[i]] = m[i] || &#x27;&#x27;;
                          }
                        
                          return uri;
                        };
                        
                        },{}],39:[function(_dereq_,module,exports){
                        (function (global){
                        /*global Blob,File*/
                        
                        /**
                         * Module requirements
                         */
                        
                        var isArray = _dereq_(&#x27;isarray&#x27;);
                        var isBuf = _dereq_(&#x27;./is-buffer&#x27;);
                        
                        /**
                         * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
                         * Anything with blobs or files should be fed through removeBlobs before coming
                         * here.
                         *
                         * @param {Object} packet - socket.io event packet
                         * @return {Object} with deconstructed packet and list of buffers
                         * @api public
                         */
                        
                        exports.deconstructPacket = function(packet){
                          var buffers = [];
                          var packetData = packet.data;
                        
                          function _deconstructPacket(data) {
                            if (!data) return data;
                        
                            if (isBuf(data)) {
                              var placeholder = { _placeholder: true, num: buffers.length };
                              buffers.push(data);
                              return placeholder;
                            } else if (isArray(data)) {
                              var newData = new Array(data.length);
                              for (var i = 0; i &lt; data.length; i++) {
                                newData[i] = _deconstructPacket(data[i]);
                              }
                              return newData;
                            } else if (&#x27;object&#x27; == typeof data &amp;&amp; !(data instanceof Date)) {
                              var newData = {};
                              for (var key in data) {
                                newData[key] = _deconstructPacket(data[key]);
                              }
                              return newData;
                            }
                            return data;
                          }
                        
                          var pack = packet;
                          pack.data = _deconstructPacket(packetData);
                          pack.attachments = buffers.length; // number of binary &#x27;attachments&#x27;
                          return {packet: pack, buffers: buffers};
                        };
                        
                        /**
                         * Reconstructs a binary packet from its placeholder packet and buffers
                         *
                         * @param {Object} packet - event packet with placeholders
                         * @param {Array} buffers - binary buffers to put in placeholder positions
                         * @return {Object} reconstructed packet
                         * @api public
                         */
                        
                        exports.reconstructPacket = function(packet, buffers) {
                          var curPlaceHolder = 0;
                        
                          function _reconstructPacket(data) {
                            if (data &amp;&amp; data._placeholder) {
                              var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
                              return buf;
                            } else if (isArray(data)) {
                              for (var i = 0; i &lt; data.length; i++) {
                                data[i] = _reconstructPacket(data[i]);
                              }
                              return data;
                            } else if (data &amp;&amp; &#x27;object&#x27; == typeof data) {
                              for (var key in data) {
                                data[key] = _reconstructPacket(data[key]);
                              }
                              return data;
                            }
                            return data;
                          }
                        
                          packet.data = _reconstructPacket(packet.data);
                          packet.attachments = undefined; // no longer useful
                          return packet;
                        };
                        
                        /**
                         * Asynchronously removes Blobs or Files from data via
                         * FileReader&#x27;s readAsArrayBuffer method. Used before encoding
                         * data as msgpack. Calls callback with the blobless data.
                         *
                         * @param {Object} data
                         * @param {Function} callback
                         * @api private
                         */
                        
                        exports.removeBlobs = function(data, callback) {
                          function _removeBlobs(obj, curKey, containingObject) {
                            if (!obj) return obj;
                        
                            // convert any blob
                            if ((global.Blob &amp;&amp; obj instanceof Blob) ||
                                (global.File &amp;&amp; obj instanceof File)) {
                              pendingBlobs++;
                        
                              // async filereader
                              var fileReader = new FileReader();
                              fileReader.onload = function() { // this.result == arraybuffer
                                if (containingObject) {
                                  containingObject[curKey] = this.result;
                                }
                                else {
                                  bloblessData = this.result;
                                }
                        
                                // if nothing pending its callback time
                                if(! --pendingBlobs) {
                                  callback(bloblessData);
                                }
                              };
                        
                              fileReader.readAsArrayBuffer(obj); // blob -&gt; arraybuffer
                            } else if (isArray(obj)) { // handle array
                              for (var i = 0; i &lt; obj.length; i++) {
                                _removeBlobs(obj[i], i, obj);
                              }
                            } else if (obj &amp;&amp; &#x27;object&#x27; == typeof obj &amp;&amp; !isBuf(obj)) { // and object
                              for (var key in obj) {
                                _removeBlobs(obj[key], key, obj);
                              }
                            }
                          }
                        
                          var pendingBlobs = 0;
                          var bloblessData = data;
                          _removeBlobs(bloblessData);
                          if (!pendingBlobs) {
                            callback(bloblessData);
                          }
                        };
                        
                        }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
                        },{&quot;./is-buffer&quot;:41,&quot;isarray&quot;:42}],40:[function(_dereq_,module,exports){
                        
                        /**
                         * Module dependencies.
                         */
                        
                        var debug = _dereq_(&#x27;debug&#x27;)(&#x27;socket.io-parser&#x27;);
                        var json = _dereq_(&#x27;json3&#x27;);
                        var isArray = _dereq_(&#x27;isarray&#x27;);
                        var Emitter = _dereq_(&#x27;component-emitter&#x27;);
                        var binary = _dereq_(&#x27;./binary&#x27;);
                        var isBuf = _dereq_(&#x27;./is-buffer&#x27;);
                        
                        /**
                         * Protocol version.
                         *
                         * @api public
                         */
                        
                        exports.protocol = 4;
                        
                        /**
                         * Packet types.
                         *
                         * @api public
                         */
                        
                        exports.types = [
                          &#x27;CONNECT&#x27;,
                          &#x27;DISCONNECT&#x27;,
                          &#x27;EVENT&#x27;,
                          &#x27;BINARY_EVENT&#x27;,
                          &#x27;ACK&#x27;,
                          &#x27;BINARY_ACK&#x27;,
                          &#x27;ERROR&#x27;
                        ];
                        
                        /**
                         * Packet type &#x60;connect&#x60;.
                         *
                         * @api public
                         */
                        
                        exports.CONNECT = 0;
                        
                        /**
                         * Packet type &#x60;disconnect&#x60;.
                         *
                         * @api public
                         */
                        
                        exports.DISCONNECT = 1;
                        
                        /**
                         * Packet type &#x60;event&#x60;.
                         *
                         * @api public
                         */
                        
                        exports.EVENT = 2;
                        
                        /**
                         * Packet type &#x60;ack&#x60;.
                         *
                         * @api public
                         */
                        
                        exports.ACK = 3;
                        
                        /**
                         * Packet type &#x60;error&#x60;.
                         *
                         * @api public
                         */
                        
                        exports.ERROR = 4;
                        
                        /**
                         * Packet type &#x27;binary event&#x27;
                         *
                         * @api public
                         */
                        
                        exports.BINARY_EVENT = 5;
                        
                        /**
                         * Packet type &#x60;binary ack&#x60;. For acks with binary arguments.
                         *
                         * @api public
                         */
                        
                        exports.BINARY_ACK = 6;
                        
                        /**
                         * Encoder constructor.
                         *
                         * @api public
                         */
                        
                        exports.Encoder = Encoder;
                        
                        /**
                         * Decoder constructor.
                         *
                         * @api public
                         */
                        
                        exports.Decoder = Decoder;
                        
                        /**
                         * A socket.io Encoder instance
                         *
                         * @api public
                         */
                        
                        function Encoder() {}
                        
                        /**
                         * Encode a packet as a single string if non-binary, or as a
                         * buffer sequence, depending on packet type.
                         *
                         * @param {Object} obj - packet object
                         * @param {Function} callback - function to handle encodings (likely engine.write)
                         * @return Calls callback with Array of encodings
                         * @api public
                         */
                        
                        Encoder.prototype.encode = function(obj, callback){
                          debug(&#x27;encoding packet %j&#x27;, obj);
                        
                          if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
                            encodeAsBinary(obj, callback);
                          }
                          else {
                            var encoding = encodeAsString(obj);
                            callback([encoding]);
                          }
                        };
                        
                        /**
                         * Encode packet as string.
                         *
                         * @param {Object} packet
                         * @return {String} encoded
                         * @api private
                         */
                        
                        function encodeAsString(obj) {
                          var str = &#x27;&#x27;;
                          var nsp = false;
                        
                          // first is type
                          str += obj.type;
                        
                          // attachments if we have them
                          if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
                            str += obj.attachments;
                            str += &#x27;-&#x27;;
                          }
                        
                          // if we have a namespace other than &#x60;/&#x60;
                          // we append it followed by a comma &#x60;,&#x60;
                          if (obj.nsp &amp;&amp; &#x27;/&#x27; != obj.nsp) {
                            nsp = true;
                            str += obj.nsp;
                          }
                        
                          // immediately followed by the id
                          if (null != obj.id) {
                            if (nsp) {
                              str += &#x27;,&#x27;;
                              nsp = false;
                            }
                            str += obj.id;
                          }
                        
                          // json data
                          if (null != obj.data) {
                            if (nsp) str += &#x27;,&#x27;;
                            str += json.stringify(obj.data);
                          }
                        
                          debug(&#x27;encoded %j as %s&#x27;, obj, str);
                          return str;
                        }
                        
                        /**
                         * Encode packet as &#x27;buffer sequence&#x27; by removing blobs, and
                         * deconstructing packet into object with placeholders and
                         * a list of buffers.
                         *
                         * @param {Object} packet
                         * @return {Buffer} encoded
                         * @api private
                         */
                        
                        function encodeAsBinary(obj, callback) {
                        
                          function writeEncoding(bloblessData) {
                            var deconstruction = binary.deconstructPacket(bloblessData);
                            var pack = encodeAsString(deconstruction.packet);
                            var buffers = deconstruction.buffers;
                        
                            buffers.unshift(pack); // add packet info to beginning of data list
                            callback(buffers); // write all the buffers
                          }
                        
                          binary.removeBlobs(obj, writeEncoding);
                        }
                        
                        /**
                         * A socket.io Decoder instance
                         *
                         * @return {Object} decoder
                         * @api public
                         */
                        
                        function Decoder() {
                          this.reconstructor = null;
                        }
                        
                        /**
                         * Mix in &#x60;Emitter&#x60; with Decoder.
                         */
                        
                        Emitter(Decoder.prototype);
                        
                        /**
                         * Decodes an ecoded packet string into packet JSON.
                         *
                         * @param {String} obj - encoded packet
                         * @return {Object} packet
                         * @api public
                         */
                        
                        Decoder.prototype.add = function(obj) {
                          var packet;
                          if (&#x27;string&#x27; == typeof obj) {
                            packet = decodeString(obj);
                            if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet&#x27;s json
                              this.reconstructor = new BinaryReconstructor(packet);
                        
                              // no attachments, labeled binary but no binary data to follow
                              if (this.reconstructor.reconPack.attachments == 0) {
                                this.emit(&#x27;decoded&#x27;, packet);
                              }
                            } else { // non-binary full packet
                              this.emit(&#x27;decoded&#x27;, packet);
                            }
                          }
                          else if (isBuf(obj) || obj.base64) { // raw binary data
                            if (!this.reconstructor) {
                              throw new Error(&#x27;got binary data when not reconstructing a packet&#x27;);
                            } else {
                              packet = this.reconstructor.takeBinaryData(obj);
                              if (packet) { // received final buffer
                                this.reconstructor = null;
                                this.emit(&#x27;decoded&#x27;, packet);
                              }
                            }
                          }
                          else {
                            throw new Error(&#x27;Unknown type: &#x27; + obj);
                          }
                        };
                        
                        /**
                         * Decode a packet String (JSON data)
                         *
                         * @param {String} str
                         * @return {Object} packet
                         * @api private
                         */
                        
                        function decodeString(str) {
                          var p = {};
                          var i = 0;
                        
                          // look up type
                          p.type = Number(str.charAt(0));
                          if (null == exports.types[p.type]) return error();
                        
                          // look up attachments if type binary
                          if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
                            p.attachments = &#x27;&#x27;;
                            while (str.charAt(++i) != &#x27;-&#x27;) {
                              p.attachments += str.charAt(i);
                            }
                            p.attachments = Number(p.attachments);
                          }
                        
                          // look up namespace (if any)
                          if (&#x27;/&#x27; == str.charAt(i + 1)) {
                            p.nsp = &#x27;&#x27;;
                            while (++i) {
                              var c = str.charAt(i);
                              if (&#x27;,&#x27; == c) break;
                              p.nsp += c;
                              if (i + 1 == str.length) break;
                            }
                          } else {
                            p.nsp = &#x27;/&#x27;;
                          }
                        
                          // look up id
                          var next = str.charAt(i + 1);
                          if (&#x27;&#x27; != next &amp;&amp; Number(next) == next) {
                            p.id = &#x27;&#x27;;
                            while (++i) {
                              var c = str.charAt(i);
                              if (null == c || Number(c) != c) {
                                --i;
                                break;
                              }
                              p.id += str.charAt(i);
                              if (i + 1 == str.length) break;
                            }
                            p.id = Number(p.id);
                          }
                        
                          // look up json data
                          if (str.charAt(++i)) {
                            try {
                              p.data = json.parse(str.substr(i));
                            } catch(e){
                              return error();
                            }
                          }
                        
                          debug(&#x27;decoded %s as %j&#x27;, str, p);
                          return p;
                        }
                        
                        /**
                         * Deallocates a parser&#x27;s resources
                         *
                         * @api public
                         */
                        
                        Decoder.prototype.destroy = function() {
                          if (this.reconstructor) {
                            this.reconstructor.finishedReconstruction();
                          }
                        };
                        
                        /**
                         * A manager of a binary event&#x27;s &#x27;buffer sequence&#x27;. Should
                         * be constructed whenever a packet of type BINARY_EVENT is
                         * decoded.
                         *
                         * @param {Object} packet
                         * @return {BinaryReconstructor} initialized reconstructor
                         * @api private
                         */
                        
                        function BinaryReconstructor(packet) {
                          this.reconPack = packet;
                          this.buffers = [];
                        }
                        
                        /**
                         * Method to be called when binary data received from connection
                         * after a BINARY_EVENT packet.
                         *
                         * @param {Buffer | ArrayBuffer} binData - the raw binary data received
                         * @return {null | Object} returns null if more binary data is expected or
                         *   a reconstructed packet object if all buffers have been received.
                         * @api private
                         */
                        
                        BinaryReconstructor.prototype.takeBinaryData = function(binData) {
                          this.buffers.push(binData);
                          if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
                            var packet = binary.reconstructPacket(this.reconPack, this.buffers);
                            this.finishedReconstruction();
                            return packet;
                          }
                          return null;
                        };
                        
                        /**
                         * Cleans up binary packet reconstruction variables.
                         *
                         * @api private
                         */
                        
                        BinaryReconstructor.prototype.finishedReconstruction = function() {
                          this.reconPack = null;
                          this.buffers = [];
                        };
                        
                        function error(data){
                          return {
                            type: exports.ERROR,
                            data: &#x27;parser error&#x27;
                          };
                        }
                        
                        },{&quot;./binary&quot;:39,&quot;./is-buffer&quot;:41,&quot;component-emitter&quot;:8,&quot;debug&quot;:9,&quot;isarray&quot;:42,&quot;json3&quot;:43}],41:[function(_dereq_,module,exports){
                        (function (global){
                        
                        module.exports = isBuf;
                        
                        /**
                         * Returns true if obj is a buffer or an arraybuffer.
                         *
                         * @api private
                         */
                        
                        function isBuf(obj) {
                          return (global.Buffer &amp;&amp; global.Buffer.isBuffer(obj)) ||
                                 (global.ArrayBuffer &amp;&amp; obj instanceof ArrayBuffer);
                        }
                        
                        }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : {})
                        },{}],42:[function(_dereq_,module,exports){
                        module.exports=_dereq_(33)
                        },{}],43:[function(_dereq_,module,exports){
                        /*! JSON v3.2.6 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */
                        ;(function (window) {
                          // Convenience aliases.
                          var getClass = {}.toString, isProperty, forEach, undef;
                        
                          // Detect the &#x60;define&#x60; function exposed by asynchronous module loaders. The
                          // strict &#x60;define&#x60; check is necessary for compatibility with &#x60;r.js&#x60;.
                          var isLoader = typeof define === &quot;function&quot; &amp;&amp; define.amd;
                        
                          // Detect native implementations.
                          var nativeJSON = typeof JSON == &quot;object&quot; &amp;&amp; JSON;
                        
                          // Set up the JSON 3 namespace, preferring the CommonJS &#x60;exports&#x60; object if
                          // available.
                          var JSON3 = typeof exports == &quot;object&quot; &amp;&amp; exports &amp;&amp; !exports.nodeType &amp;&amp; exports;
                        
                          if (JSON3 &amp;&amp; nativeJSON) {
                            // Explicitly delegate to the native &#x60;stringify&#x60; and &#x60;parse&#x60;
                            // implementations in CommonJS environments.
                            JSON3.stringify = nativeJSON.stringify;
                            JSON3.parse = nativeJSON.parse;
                          } else {
                            // Export for web browsers, JavaScript engines, and asynchronous module
                            // loaders, using the global &#x60;JSON&#x60; object if available.
                            JSON3 = window.JSON = nativeJSON || {};
                          }
                        
                          // Test the &#x60;Date#getUTC*&#x60; methods. Based on work by @Yaffle.
                          var isExtended = new Date(-3509827334573292);
                          try {
                            // The &#x60;getUTCFullYear&#x60;, &#x60;Month&#x60;, and &#x60;Date&#x60; methods return nonsensical
                            // results for certain dates in Opera &gt;= 10.53.
                            isExtended = isExtended.getUTCFullYear() == -109252 &amp;&amp; isExtended.getUTCMonth() === 0 &amp;&amp; isExtended.getUTCDate() === 1 &amp;&amp;
                              // Safari &lt; 2.0.2 stores the internal millisecond time value correctly,
                              // but clips the values returned by the date methods to the range of
                              // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
                              isExtended.getUTCHours() == 10 &amp;&amp; isExtended.getUTCMinutes() == 37 &amp;&amp; isExtended.getUTCSeconds() == 6 &amp;&amp; isExtended.getUTCMilliseconds() == 708;
                          } catch (exception) {}
                        
                          // Internal: Determines whether the native &#x60;JSON.stringify&#x60; and &#x60;parse&#x60;
                          // implementations are spec-compliant. Based on work by Ken Snyder.
                          function has(name) {
                            if (has[name] !== undef) {
                              // Return cached feature test result.
                              return has[name];
                            }
                        
                            var isSupported;
                            if (name == &quot;bug-string-char-index&quot;) {
                              // IE &lt;= 7 doesn&#x27;t support accessing string characters using square
                              // bracket notation. IE 8 only supports this for primitives.
                              isSupported = &quot;a&quot;[0] != &quot;a&quot;;
                            } else if (name == &quot;json&quot;) {
                              // Indicates whether both &#x60;JSON.stringify&#x60; and &#x60;JSON.parse&#x60; are
                              // supported.
                              isSupported = has(&quot;json-stringify&quot;) &amp;&amp; has(&quot;json-parse&quot;);
                            } else {
                              var value, serialized = &#x27;{&quot;a&quot;:[1,true,false,null,&quot;\\u0000\\b\\n\\f\\r\\t&quot;]}&#x27;;
                              // Test &#x60;JSON.stringify&#x60;.
                              if (name == &quot;json-stringify&quot;) {
                                var stringify = JSON3.stringify, stringifySupported = typeof stringify == &quot;function&quot; &amp;&amp; isExtended;
                                if (stringifySupported) {
                                  // A test function object with a custom &#x60;toJSON&#x60; method.
                                  (value = function () {
                                    return 1;
                                  }).toJSON = value;
                                  try {
                                    stringifySupported =
                                      // Firefox 3.1b1 and b2 serialize string, number, and boolean
                                      // primitives as object literals.
                                      stringify(0) === &quot;0&quot; &amp;&amp;
                                      // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                                      // literals.
                                      stringify(new Number()) === &quot;0&quot; &amp;&amp;
                                      stringify(new String()) == &#x27;&quot;&quot;&#x27; &amp;&amp;
                                      // FF 3.1b1, 2 throw an error if the value is &#x60;null&#x60;, &#x60;undefined&#x60;, or
                                      // does not define a canonical JSON representation (this applies to
                                      // objects with &#x60;toJSON&#x60; properties as well, *unless* they are nested
                                      // within an object or array).
                                      stringify(getClass) === undef &amp;&amp;
                                      // IE 8 serializes &#x60;undefined&#x60; as &#x60;&quot;undefined&quot;&#x60;. Safari &lt;= 5.1.7 and
                                      // FF 3.1b3 pass this test.
                                      stringify(undef) === undef &amp;&amp;
                                      // Safari &lt;= 5.1.7 and FF 3.1b3 throw &#x60;Error&#x60;s and &#x60;TypeError&#x60;s,
                                      // respectively, if the value is omitted entirely.
                                      stringify() === undef &amp;&amp;
                                      // FF 3.1b1, 2 throw an error if the given value is not a number,
                                      // string, array, object, Boolean, or &#x60;null&#x60; literal. This applies to
                                      // objects with custom &#x60;toJSON&#x60; methods as well, unless they are nested
                                      // inside object or array literals. YUI 3.0.0b1 ignores custom &#x60;toJSON&#x60;
                                      // methods entirely.
                                      stringify(value) === &quot;1&quot; &amp;&amp;
                                      stringify([value]) == &quot;[1]&quot; &amp;&amp;
                                      // Prototype &lt;= 1.6.1 serializes &#x60;[undefined]&#x60; as &#x60;&quot;[]&quot;&#x60; instead of
                                      // &#x60;&quot;[null]&quot;&#x60;.
                                      stringify([undef]) == &quot;[null]&quot; &amp;&amp;
                                      // YUI 3.0.0b1 fails to serialize &#x60;null&#x60; literals.
                                      stringify(null) == &quot;null&quot; &amp;&amp;
                                      // FF 3.1b1, 2 halts serialization if an array contains a function:
                                      // &#x60;[1, true, getClass, 1]&#x60; serializes as &quot;[1,true,],&quot;. FF 3.1b3
                                      // elides non-JSON values from objects and arrays, unless they
                                      // define custom &#x60;toJSON&#x60; methods.
                                      stringify([undef, getClass, null]) == &quot;[null,null,null]&quot; &amp;&amp;
                                      // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                                      // where character escape codes are expected (e.g., &#x60;\b&#x60; =&gt; &#x60;\u0008&#x60;).
                                      stringify({ &quot;a&quot;: [value, true, false, null, &quot;\x00\b\n\f\r\t&quot;] }) == serialized &amp;&amp;
                                      // FF 3.1b1 and b2 ignore the &#x60;filter&#x60; and &#x60;width&#x60; arguments.
                                      stringify(null, value) === &quot;1&quot; &amp;&amp;
                                      stringify([1, 2], null, 1) == &quot;[\n 1,\n 2\n]&quot; &amp;&amp;
                                      // JSON 2, Prototype &lt;= 1.7, and older WebKit builds incorrectly
                                      // serialize extended years.
                                      stringify(new Date(-8.64e15)) == &#x27;&quot;-271821-04-20T00:00:00.000Z&quot;&#x27; &amp;&amp;
                                      // The milliseconds are optional in ES 5, but required in 5.1.
                                      stringify(new Date(8.64e15)) == &#x27;&quot;+275760-09-13T00:00:00.000Z&quot;&#x27; &amp;&amp;
                                      // Firefox &lt;= 11.0 incorrectly serializes years prior to 0 as negative
                                      // four-digit years instead of six-digit years. Credits: @Yaffle.
                                      stringify(new Date(-621987552e5)) == &#x27;&quot;-000001-01-01T00:00:00.000Z&quot;&#x27; &amp;&amp;
                                      // Safari &lt;= 5.1.5 and Opera &gt;= 10.53 incorrectly serialize millisecond
                                      // values less than 1000. Credits: @Yaffle.
                                      stringify(new Date(-1)) == &#x27;&quot;1969-12-31T23:59:59.999Z&quot;&#x27;;
                                  } catch (exception) {
                                    stringifySupported = false;
                                  }
                                }
                                isSupported = stringifySupported;
                              }
                              // Test &#x60;JSON.parse&#x60;.
                              if (name == &quot;json-parse&quot;) {
                                var parse = JSON3.parse;
                                if (typeof parse == &quot;function&quot;) {
                                  try {
                                    // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
                                    // Conforming implementations should also coerce the initial argument to
                                    // a string prior to parsing.
                                    if (parse(&quot;0&quot;) === 0 &amp;&amp; !parse(false)) {
                                      // Simple parsing test.
                                      value = parse(serialized);
                                      var parseSupported = value[&quot;a&quot;].length == 5 &amp;&amp; value[&quot;a&quot;][0] === 1;
                                      if (parseSupported) {
                                        try {
                                          // Safari &lt;= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                                          parseSupported = !parse(&#x27;&quot;\t&quot;&#x27;);
                                        } catch (exception) {}
                                        if (parseSupported) {
                                          try {
                                            // FF 4.0 and 4.0.1 allow leading &#x60;+&#x60; signs and leading
                                            // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                                            // certain octal literals.
                                            parseSupported = parse(&quot;01&quot;) !== 1;
                                          } catch (exception) {}
                                        }
                                        if (parseSupported) {
                                          try {
                                            // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                                            // points. These environments, along with FF 3.1b1 and 2,
                                            // also allow trailing commas in JSON objects and arrays.
                                            parseSupported = parse(&quot;1.&quot;) !== 1;
                                          } catch (exception) {}
                                        }
                                      }
                                    }
                                  } catch (exception) {
                                    parseSupported = false;
                                  }
                                }
                                isSupported = parseSupported;
                              }
                            }
                            return has[name] = !!isSupported;
                          }
                        
                          if (!has(&quot;json&quot;)) {
                            // Common &#x60;[[Class]]&#x60; name aliases.
                            var functionClass = &quot;[object Function]&quot;;
                            var dateClass = &quot;[object Date]&quot;;
                            var numberClass = &quot;[object Number]&quot;;
                            var stringClass = &quot;[object String]&quot;;
                            var arrayClass = &quot;[object Array]&quot;;
                            var booleanClass = &quot;[object Boolean]&quot;;
                        
                            // Detect incomplete support for accessing string characters by index.
                            var charIndexBuggy = has(&quot;bug-string-char-index&quot;);
                        
                            // Define additional utility methods if the &#x60;Date&#x60; methods are buggy.
                            if (!isExtended) {
                              var floor = Math.floor;
                              // A mapping between the months of the year and the number of days between
                              // January 1st and the first of the respective month.
                              var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
                              // Internal: Calculates the number of days between the Unix epoch and the
                              // first day of the given month.
                              var getDay = function (year, month) {
                                return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month &gt; 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
                              };
                            }
                        
                            // Internal: Determines if a property is a direct property of the given
                            // object. Delegates to the native &#x60;Object#hasOwnProperty&#x60; method.
                            if (!(isProperty = {}.hasOwnProperty)) {
                              isProperty = function (property) {
                                var members = {}, constructor;
                                if ((members.__proto__ = null, members.__proto__ = {
                                  // The *proto* property cannot be set multiple times in recent
                                  // versions of Firefox and SeaMonkey.
                                  &quot;toString&quot;: 1
                                }, members).toString != getClass) {
                                  // Safari &lt;= 2.0.3 doesn&#x27;t implement &#x60;Object#hasOwnProperty&#x60;, but
                                  // supports the mutable *proto* property.
                                  isProperty = function (property) {
                                    // Capture and break the object&#x27;s prototype chain (see section 8.6.2
                                    // of the ES 5.1 spec). The parenthesized expression prevents an
                                    // unsafe transformation by the Closure Compiler.
                                    var original = this.__proto__, result = property in (this.__proto__ = null, this);
                                    // Restore the original prototype chain.
                                    this.__proto__ = original;
                                    return result;
                                  };
                                } else {
                                  // Capture a reference to the top-level &#x60;Object&#x60; constructor.
                                  constructor = members.constructor;
                                  // Use the &#x60;constructor&#x60; property to simulate &#x60;Object#hasOwnProperty&#x60; in
                                  // other environments.
                                  isProperty = function (property) {
                                    var parent = (this.constructor || constructor).prototype;
                                    return property in this &amp;&amp; !(property in parent &amp;&amp; this[property] === parent[property]);
                                  };
                                }
                                members = null;
                                return isProperty.call(this, property);
                              };
                            }
                        
                            // Internal: A set of primitive types used by &#x60;isHostType&#x60;.
                            var PrimitiveTypes = {
                              &#x27;boolean&#x27;: 1,
                              &#x27;number&#x27;: 1,
                              &#x27;string&#x27;: 1,
                              &#x27;undefined&#x27;: 1
                            };
                        
                            // Internal: Determines if the given object &#x60;property&#x60; value is a
                            // non-primitive.
                            var isHostType = function (object, property) {
                              var type = typeof object[property];
                              return type == &#x27;object&#x27; ? !!object[property] : !PrimitiveTypes[type];
                            };
                        
                            // Internal: Normalizes the &#x60;for...in&#x60; iteration algorithm across
                            // environments. Each enumerated key is yielded to a &#x60;callback&#x60; function.
                            forEach = function (object, callback) {
                              var size = 0, Properties, members, property;
                        
                              // Tests for bugs in the current environment&#x27;s &#x60;for...in&#x60; algorithm. The
                              // &#x60;valueOf&#x60; property inherits the non-enumerable flag from
                              // &#x60;Object.prototype&#x60; in older versions of IE, Netscape, and Mozilla.
                              (Properties = function () {
                                this.valueOf = 0;
                              }).prototype.valueOf = 0;
                        
                              // Iterate over a new instance of the &#x60;Properties&#x60; class.
                              members = new Properties();
                              for (property in members) {
                                // Ignore all properties inherited from &#x60;Object.prototype&#x60;.
                                if (isProperty.call(members, property)) {
                                  size++;
                                }
                              }
                              Properties = members = null;
                        
                              // Normalize the iteration algorithm.
                              if (!size) {
                                // A list of non-enumerable properties inherited from &#x60;Object.prototype&#x60;.
                                members = [&quot;valueOf&quot;, &quot;toString&quot;, &quot;toLocaleString&quot;, &quot;propertyIsEnumerable&quot;, &quot;isPrototypeOf&quot;, &quot;hasOwnProperty&quot;, &quot;constructor&quot;];
                                // IE &lt;= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
                                // properties.
                                forEach = function (object, callback) {
                                  var isFunction = getClass.call(object) == functionClass, property, length;
                                  var hasProperty = !isFunction &amp;&amp; typeof object.constructor != &#x27;function&#x27; &amp;&amp; isHostType(object, &#x27;hasOwnProperty&#x27;) ? object.hasOwnProperty : isProperty;
                                  for (property in object) {
                                    // Gecko &lt;= 1.0 enumerates the &#x60;prototype&#x60; property of functions under
                                    // certain conditions; IE does not.
                                    if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; hasProperty.call(object, property)) {
                                      callback(property);
                                    }
                                  }
                                  // Manually invoke the callback for each non-enumerable property.
                                  for (length = members.length; property = members[--length]; hasProperty.call(object, property) &amp;&amp; callback(property));
                                };
                              } else if (size == 2) {
                                // Safari &lt;= 2.0.4 enumerates shadowed properties twice.
                                forEach = function (object, callback) {
                                  // Create a set of iterated properties.
                                  var members = {}, isFunction = getClass.call(object) == functionClass, property;
                                  for (property in object) {
                                    // Store each property name to prevent double enumeration. The
                                    // &#x60;prototype&#x60; property of functions is not enumerated due to cross-
                                    // environment inconsistencies.
                                    if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; !isProperty.call(members, property) &amp;&amp; (members[property] = 1) &amp;&amp; isProperty.call(object, property)) {
                                      callback(property);
                                    }
                                  }
                                };
                              } else {
                                // No bugs detected; use the standard &#x60;for...in&#x60; algorithm.
                                forEach = function (object, callback) {
                                  var isFunction = getClass.call(object) == functionClass, property, isConstructor;
                                  for (property in object) {
                                    if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; isProperty.call(object, property) &amp;&amp; !(isConstructor = property === &quot;constructor&quot;)) {
                                      callback(property);
                                    }
                                  }
                                  // Manually invoke the callback for the &#x60;constructor&#x60; property due to
                                  // cross-environment inconsistencies.
                                  if (isConstructor || isProperty.call(object, (property = &quot;constructor&quot;))) {
                                    callback(property);
                                  }
                                };
                              }
                              return forEach(object, callback);
                            };
                        
                            // Public: Serializes a JavaScript &#x60;value&#x60; as a JSON string. The optional
                            // &#x60;filter&#x60; argument may specify either a function that alters how object and
                            // array members are serialized, or an array of strings and numbers that
                            // indicates which properties should be serialized. The optional &#x60;width&#x60;
                            // argument may be either a string or number that specifies the indentation
                            // level of the output.
                            if (!has(&quot;json-stringify&quot;)) {
                              // Internal: A map of control characters and their escaped equivalents.
                              var Escapes = {
                                92: &quot;\\\\&quot;,
                                34: &#x27;\\&quot;&#x27;,
                                8: &quot;\\b&quot;,
                                12: &quot;\\f&quot;,
                                10: &quot;\\n&quot;,
                                13: &quot;\\r&quot;,
                                9: &quot;\\t&quot;
                              };
                        
                              // Internal: Converts &#x60;value&#x60; into a zero-padded string such that its
                              // length is at least equal to &#x60;width&#x60;. The &#x60;width&#x60; must be &lt;= 6.
                              var leadingZeroes = &quot;000000&quot;;
                              var toPaddedString = function (width, value) {
                                // The &#x60;|| 0&#x60; expression is necessary to work around a bug in
                                // Opera &lt;= 7.54u2 where &#x60;0 == -0&#x60;, but &#x60;String(-0) !== &quot;0&quot;&#x60;.
                                return (leadingZeroes + (value || 0)).slice(-width);
                              };
                        
                              // Internal: Double-quotes a string &#x60;value&#x60;, replacing all ASCII control
                              // characters (characters with code unit values between 0 and 31) with
                              // their escaped equivalents. This is an implementation of the
                              // &#x60;Quote(value)&#x60; operation defined in ES 5.1 section 15.12.3.
                              var unicodePrefix = &quot;\\u00&quot;;
                              var quote = function (value) {
                                var result = &#x27;&quot;&#x27;, index = 0, length = value.length, isLarge = length &gt; 10 &amp;&amp; charIndexBuggy, symbols;
                                if (isLarge) {
                                  symbols = value.split(&quot;&quot;);
                                }
                                for (; index &lt; length; index++) {
                                  var charCode = value.charCodeAt(index);
                                  // If the character is a control character, append its Unicode or
                                  // shorthand escape sequence; otherwise, append the character as-is.
                                  switch (charCode) {
                                    case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                                      result += Escapes[charCode];
                                      break;
                                    default:
                                      if (charCode &lt; 32) {
                                        result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                                        break;
                                      }
                                      result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];
                                  }
                                }
                                return result + &#x27;&quot;&#x27;;
                              };
                        
                              // Internal: Recursively serializes an object. Implements the
                              // &#x60;Str(key, holder)&#x60;, &#x60;JO(value)&#x60;, and &#x60;JA(value)&#x60; operations.
                              var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
                                var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
                                try {
                                  // Necessary for host object support.
                                  value = object[property];
                                } catch (exception) {}
                                if (typeof value == &quot;object&quot; &amp;&amp; value) {
                                  className = getClass.call(value);
                                  if (className == dateClass &amp;&amp; !isProperty.call(value, &quot;toJSON&quot;)) {
                                    if (value &gt; -1 / 0 &amp;&amp; value &lt; 1 / 0) {
                                      // Dates are serialized according to the &#x60;Date#toJSON&#x60; method
                                      // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                                      // for the ISO 8601 date time string format.
                                      if (getDay) {
                                        // Manually compute the year, month, date, hours, minutes,
                                        // seconds, and milliseconds if the &#x60;getUTC*&#x60; methods are
                                        // buggy. Adapted from @Yaffle&#x27;s &#x60;date-shim&#x60; project.
                                        date = floor(value / 864e5);
                                        for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) &lt;= date; year++);
                                        for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) &lt;= date; month++);
                                        date = 1 + date - getDay(year, month);
                                        // The &#x60;time&#x60; value specifies the time within the day (see ES
                                        // 5.1 section 15.9.1.2). The formula &#x60;(A % B + B) % B&#x60; is used
                                        // to compute &#x60;A modulo B&#x60;, as the &#x60;%&#x60; operator does not
                                        // correspond to the &#x60;modulo&#x60; operation for negative numbers.
                                        time = (value % 864e5 + 864e5) % 864e5;
                                        // The hours, minutes, seconds, and milliseconds are obtained by
                                        // decomposing the time within the day. See section 15.9.1.10.
                                        hours = floor(time / 36e5) % 24;
                                        minutes = floor(time / 6e4) % 60;
                                        seconds = floor(time / 1e3) % 60;
                                        milliseconds = time % 1e3;
                                      } else {
                                        year = value.getUTCFullYear();
                                        month = value.getUTCMonth();
                                        date = value.getUTCDate();
                                        hours = value.getUTCHours();
                                        minutes = value.getUTCMinutes();
                                        seconds = value.getUTCSeconds();
                                        milliseconds = value.getUTCMilliseconds();
                                      }
                                      // Serialize extended years correctly.
                                      value = (year &lt;= 0 || year &gt;= 1e4 ? (year &lt; 0 ? &quot;-&quot; : &quot;+&quot;) + toPaddedString(6, year &lt; 0 ? -year : year) : toPaddedString(4, year)) +
                                        &quot;-&quot; + toPaddedString(2, month + 1) + &quot;-&quot; + toPaddedString(2, date) +
                                        // Months, dates, hours, minutes, and seconds should have two
                                        // digits; milliseconds should have three.
                                        &quot;T&quot; + toPaddedString(2, hours) + &quot;:&quot; + toPaddedString(2, minutes) + &quot;:&quot; + toPaddedString(2, seconds) +
                                        // Milliseconds are optional in ES 5.0, but required in 5.1.
                                        &quot;.&quot; + toPaddedString(3, milliseconds) + &quot;Z&quot;;
                                    } else {
                                      value = null;
                                    }
                                  } else if (typeof value.toJSON == &quot;function&quot; &amp;&amp; ((className != numberClass &amp;&amp; className != stringClass &amp;&amp; className != arrayClass) || isProperty.call(value, &quot;toJSON&quot;))) {
                                    // Prototype &lt;= 1.6.1 adds non-standard &#x60;toJSON&#x60; methods to the
                                    // &#x60;Number&#x60;, &#x60;String&#x60;, &#x60;Date&#x60;, and &#x60;Array&#x60; prototypes. JSON 3
                                    // ignores all &#x60;toJSON&#x60; methods on these objects unless they are
                                    // defined directly on an instance.
                                    value = value.toJSON(property);
                                  }
                                }
                                if (callback) {
                                  // If a replacement function was provided, call it to obtain the value
                                  // for serialization.
                                  value = callback.call(object, property, value);
                                }
                                if (value === null) {
                                  return &quot;null&quot;;
                                }
                                className = getClass.call(value);
                                if (className == booleanClass) {
                                  // Booleans are represented literally.
                                  return &quot;&quot; + value;
                                } else if (className == numberClass) {
                                  // JSON numbers must be finite. &#x60;Infinity&#x60; and &#x60;NaN&#x60; are serialized as
                                  // &#x60;&quot;null&quot;&#x60;.
                                  return value &gt; -1 / 0 &amp;&amp; value &lt; 1 / 0 ? &quot;&quot; + value : &quot;null&quot;;
                                } else if (className == stringClass) {
                                  // Strings are double-quoted and escaped.
                                  return quote(&quot;&quot; + value);
                                }
                                // Recursively serialize objects and arrays.
                                if (typeof value == &quot;object&quot;) {
                                  // Check for cyclic structures. This is a linear search; performance
                                  // is inversely proportional to the number of unique nested objects.
                                  for (length = stack.length; length--;) {
                                    if (stack[length] === value) {
                                      // Cyclic structures cannot be serialized by &#x60;JSON.stringify&#x60;.
                                      throw TypeError();
                                    }
                                  }
                                  // Add the object to the stack of traversed objects.
                                  stack.push(value);
                                  results = [];
                                  // Save the current indentation level and indent one additional level.
                                  prefix = indentation;
                                  indentation += whitespace;
                                  if (className == arrayClass) {
                                    // Recursively serialize array elements.
                                    for (index = 0, length = value.length; index &lt; length; index++) {
                                      element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                                      results.push(element === undef ? &quot;null&quot; : element);
                                    }
                                    result = results.length ? (whitespace ? &quot;[\n&quot; + indentation + results.join(&quot;,\n&quot; + indentation) + &quot;\n&quot; + prefix + &quot;]&quot; : (&quot;[&quot; + results.join(&quot;,&quot;) + &quot;]&quot;)) : &quot;[]&quot;;
                                  } else {
                                    // Recursively serialize object members. Members are selected from
                                    // either a user-specified list of property names, or the object
                                    // itself.
                                    forEach(properties || value, function (property) {
                                      var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                                      if (element !== undef) {
                                        // According to ES 5.1 section 15.12.3: &quot;If &#x60;gap&#x60; {whitespace}
                                        // is not the empty string, let &#x60;member&#x60; {quote(property) + &quot;:&quot;}
                                        // be the concatenation of &#x60;member&#x60; and the &#x60;space&#x60; character.&quot;
                                        // The &quot;&#x60;space&#x60; character&quot; refers to the literal space
                                        // character, not the &#x60;space&#x60; {width} argument provided to
                                        // &#x60;JSON.stringify&#x60;.
                                        results.push(quote(property) + &quot;:&quot; + (whitespace ? &quot; &quot; : &quot;&quot;) + element);
                                      }
                                    });
                                    result = results.length ? (whitespace ? &quot;{\n&quot; + indentation + results.join(&quot;,\n&quot; + indentation) + &quot;\n&quot; + prefix + &quot;}&quot; : (&quot;{&quot; + results.join(&quot;,&quot;) + &quot;}&quot;)) : &quot;{}&quot;;
                                  }
                                  // Remove the object from the traversed object stack.
                                  stack.pop();
                                  return result;
                                }
                              };
                        
                              // Public: &#x60;JSON.stringify&#x60;. See ES 5.1 section 15.12.3.
                              JSON3.stringify = function (source, filter, width) {
                                var whitespace, callback, properties, className;
                                if (typeof filter == &quot;function&quot; || typeof filter == &quot;object&quot; &amp;&amp; filter) {
                                  if ((className = getClass.call(filter)) == functionClass) {
                                    callback = filter;
                                  } else if (className == arrayClass) {
                                    // Convert the property names array into a makeshift set.
                                    properties = {};
                                    for (var index = 0, length = filter.length, value; index &lt; length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) &amp;&amp; (properties[value] = 1));
                                  }
                                }
                                if (width) {
                                  if ((className = getClass.call(width)) == numberClass) {
                                    // Convert the &#x60;width&#x60; to an integer and create a string containing
                                    // &#x60;width&#x60; number of space characters.
                                    if ((width -= width % 1) &gt; 0) {
                                      for (whitespace = &quot;&quot;, width &gt; 10 &amp;&amp; (width = 10); whitespace.length &lt; width; whitespace += &quot; &quot;);
                                    }
                                  } else if (className == stringClass) {
                                    whitespace = width.length &lt;= 10 ? width : width.slice(0, 10);
                                  }
                                }
                                // Opera &lt;= 7.54u2 discards the values associated with empty string keys
                                // (&#x60;&quot;&quot;&#x60;) only if they are used directly within an object member list
                                // (e.g., &#x60;!(&quot;&quot; in { &quot;&quot;: 1})&#x60;).
                                return serialize(&quot;&quot;, (value = {}, value[&quot;&quot;] = source, value), callback, properties, whitespace, &quot;&quot;, []);
                              };
                            }
                        
                            // Public: Parses a JSON source string.
                            if (!has(&quot;json-parse&quot;)) {
                              var fromCharCode = String.fromCharCode;
                        
                              // Internal: A map of escaped control characters and their unescaped
                              // equivalents.
                              var Unescapes = {
                                92: &quot;\\&quot;,
                                34: &#x27;&quot;&#x27;,
                                47: &quot;/&quot;,
                                98: &quot;\b&quot;,
                                116: &quot;\t&quot;,
                                110: &quot;\n&quot;,
                                102: &quot;\f&quot;,
                                114: &quot;\r&quot;
                              };
                        
                              // Internal: Stores the parser state.
                              var Index, Source;
                        
                              // Internal: Resets the parser state and throws a &#x60;SyntaxError&#x60;.
                              var abort = function() {
                                Index = Source = null;
                                throw SyntaxError();
                              };
                        
                              // Internal: Returns the next token, or &#x60;&quot;$&quot;&#x60; if the parser has reached
                              // the end of the source string. A token may be a string, number, &#x60;null&#x60;
                              // literal, or Boolean literal.
                              var lex = function () {
                                var source = Source, length = source.length, value, begin, position, isSigned, charCode;
                                while (Index &lt; length) {
                                  charCode = source.charCodeAt(Index);
                                  switch (charCode) {
                                    case 9: case 10: case 13: case 32:
                                      // Skip whitespace tokens, including tabs, carriage returns, line
                                      // feeds, and space characters.
                                      Index++;
                                      break;
                                    case 123: case 125: case 91: case 93: case 58: case 44:
                                      // Parse a punctuator token (&#x60;{&#x60;, &#x60;}&#x60;, &#x60;[&#x60;, &#x60;]&#x60;, &#x60;:&#x60;, or &#x60;,&#x60;) at
                                      // the current position.
                                      value = charIndexBuggy ? source.charAt(Index) : source[Index];
                                      Index++;
                                      return value;
                                    case 34:
                                      // &#x60;&quot;&#x60; delimits a JSON string; advance to the next character and
                                      // begin parsing the string. String tokens are prefixed with the
                                      // sentinel &#x60;@&#x60; character to distinguish them from punctuators and
                                      // end-of-string tokens.
                                      for (value = &quot;@&quot;, Index++; Index &lt; length;) {
                                        charCode = source.charCodeAt(Index);
                                        if (charCode &lt; 32) {
                                          // Unescaped ASCII control characters (those with a code unit
                                          // less than the space character) are not permitted.
                                          abort();
                                        } else if (charCode == 92) {
                                          // A reverse solidus (&#x60;\&#x60;) marks the beginning of an escaped
                                          // control character (including &#x60;&quot;&#x60;, &#x60;\&#x60;, and &#x60;/&#x60;) or Unicode
                                          // escape sequence.
                                          charCode = source.charCodeAt(++Index);
                                          switch (charCode) {
                                            case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                                              // Revive escaped control characters.
                                              value += Unescapes[charCode];
                                              Index++;
                                              break;
                                            case 117:
                                              // &#x60;\u&#x60; marks the beginning of a Unicode escape sequence.
                                              // Advance to the first character and validate the
                                              // four-digit code point.
                                              begin = ++Index;
                                              for (position = Index + 4; Index &lt; position; Index++) {
                                                charCode = source.charCodeAt(Index);
                                                // A valid sequence comprises four hexdigits (case-
                                                // insensitive) that form a single hexadecimal value.
                                                if (!(charCode &gt;= 48 &amp;&amp; charCode &lt;= 57 || charCode &gt;= 97 &amp;&amp; charCode &lt;= 102 || charCode &gt;= 65 &amp;&amp; charCode &lt;= 70)) {
                                                  // Invalid Unicode escape sequence.
                                                  abort();
                                                }
                                              }
                                              // Revive the escaped character.
                                              value += fromCharCode(&quot;0x&quot; + source.slice(begin, Index));
                                              break;
                                            default:
                                              // Invalid escape sequence.
                                              abort();
                                          }
                                        } else {
                                          if (charCode == 34) {
                                            // An unescaped double-quote character marks the end of the
                                            // string.
                                            break;
                                          }
                                          charCode = source.charCodeAt(Index);
                                          begin = Index;
                                          // Optimize for the common case where a string is valid.
                                          while (charCode &gt;= 32 &amp;&amp; charCode != 92 &amp;&amp; charCode != 34) {
                                            charCode = source.charCodeAt(++Index);
                                          }
                                          // Append the string as-is.
                                          value += source.slice(begin, Index);
                                        }
                                      }
                                      if (source.charCodeAt(Index) == 34) {
                                        // Advance to the next character and return the revived string.
                                        Index++;
                                        return value;
                                      }
                                      // Unterminated string.
                                      abort();
                                    default:
                                      // Parse numbers and literals.
                                      begin = Index;
                                      // Advance past the negative sign, if one is specified.
                                      if (charCode == 45) {
                                        isSigned = true;
                                        charCode = source.charCodeAt(++Index);
                                      }
                                      // Parse an integer or floating-point value.
                                      if (charCode &gt;= 48 &amp;&amp; charCode &lt;= 57) {
                                        // Leading zeroes are interpreted as octal literals.
                                        if (charCode == 48 &amp;&amp; ((charCode = source.charCodeAt(Index + 1)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57)) {
                                          // Illegal octal literal.
                                          abort();
                                        }
                                        isSigned = false;
                                        // Parse the integer component.
                                        for (; Index &lt; length &amp;&amp; ((charCode = source.charCodeAt(Index)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57); Index++);
                                        // Floats cannot contain a leading decimal point; however, this
                                        // case is already accounted for by the parser.
                                        if (source.charCodeAt(Index) == 46) {
                                          position = ++Index;
                                          // Parse the decimal component.
                                          for (; position &lt; length &amp;&amp; ((charCode = source.charCodeAt(position)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57); position++);
                                          if (position == Index) {
                                            // Illegal trailing decimal.
                                            abort();
                                          }
                                          Index = position;
                                        }
                                        // Parse exponents. The &#x60;e&#x60; denoting the exponent is
                                        // case-insensitive.
                                        charCode = source.charCodeAt(Index);
                                        if (charCode == 101 || charCode == 69) {
                                          charCode = source.charCodeAt(++Index);
                                          // Skip past the sign following the exponent, if one is
                                          // specified.
                                          if (charCode == 43 || charCode == 45) {
                                            Index++;
                                          }
                                          // Parse the exponential component.
                                          for (position = Index; position &lt; length &amp;&amp; ((charCode = source.charCodeAt(position)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57); position++);
                                          if (position == Index) {
                                            // Illegal empty exponent.
                                            abort();
                                          }
                                          Index = position;
                                        }
                                        // Coerce the parsed value to a JavaScript number.
                                        return +source.slice(begin, Index);
                                      }
                                      // A negative sign may only precede numbers.
                                      if (isSigned) {
                                        abort();
                                      }
                                      // &#x60;true&#x60;, &#x60;false&#x60;, and &#x60;null&#x60; literals.
                                      if (source.slice(Index, Index + 4) == &quot;true&quot;) {
                                        Index += 4;
                                        return true;
                                      } else if (source.slice(Index, Index + 5) == &quot;false&quot;) {
                                        Index += 5;
                                        return false;
                                      } else if (source.slice(Index, Index + 4) == &quot;null&quot;) {
                                        Index += 4;
                                        return null;
                                      }
                                      // Unrecognized token.
                                      abort();
                                  }
                                }
                                // Return the sentinel &#x60;$&#x60; character if the parser has reached the end
                                // of the source string.
                                return &quot;$&quot;;
                              };
                        
                              // Internal: Parses a JSON &#x60;value&#x60; token.
                              var get = function (value) {
                                var results, hasMembers;
                                if (value == &quot;$&quot;) {
                                  // Unexpected end of input.
                                  abort();
                                }
                                if (typeof value == &quot;string&quot;) {
                                  if ((charIndexBuggy ? value.charAt(0) : value[0]) == &quot;@&quot;) {
                                    // Remove the sentinel &#x60;@&#x60; character.
                                    return value.slice(1);
                                  }
                                  // Parse object and array literals.
                                  if (value == &quot;[&quot;) {
                                    // Parses a JSON array, returning a new JavaScript array.
                                    results = [];
                                    for (;; hasMembers || (hasMembers = true)) {
                                      value = lex();
                                      // A closing square bracket marks the end of the array literal.
                                      if (value == &quot;]&quot;) {
                                        break;
                                      }
                                      // If the array literal contains elements, the current token
                                      // should be a comma separating the previous element from the
                                      // next.
                                      if (hasMembers) {
                                        if (value == &quot;,&quot;) {
                                          value = lex();
                                          if (value == &quot;]&quot;) {
                                            // Unexpected trailing &#x60;,&#x60; in array literal.
                                            abort();
                                          }
                                        } else {
                                          // A &#x60;,&#x60; must separate each array element.
                                          abort();
                                        }
                                      }
                                      // Elisions and leading commas are not permitted.
                                      if (value == &quot;,&quot;) {
                                        abort();
                                      }
                                      results.push(get(value));
                                    }
                                    return results;
                                  } else if (value == &quot;{&quot;) {
                                    // Parses a JSON object, returning a new JavaScript object.
                                    results = {};
                                    for (;; hasMembers || (hasMembers = true)) {
                                      value = lex();
                                      // A closing curly brace marks the end of the object literal.
                                      if (value == &quot;}&quot;) {
                                        break;
                                      }
                                      // If the object literal contains members, the current token
                                      // should be a comma separator.
                                      if (hasMembers) {
                                        if (value == &quot;,&quot;) {
                                          value = lex();
                                          if (value == &quot;}&quot;) {
                                            // Unexpected trailing &#x60;,&#x60; in object literal.
                                            abort();
                                          }
                                        } else {
                                          // A &#x60;,&#x60; must separate each object member.
                                          abort();
                                        }
                                      }
                                      // Leading commas are not permitted, object property names must be
                                      // double-quoted strings, and a &#x60;:&#x60; must separate each property
                                      // name and value.
                                      if (value == &quot;,&quot; || typeof value != &quot;string&quot; || (charIndexBuggy ? value.charAt(0) : value[0]) != &quot;@&quot; || lex() != &quot;:&quot;) {
                                        abort();
                                      }
                                      results[value.slice(1)] = get(lex());
                                    }
                                    return results;
                                  }
                                  // Unexpected token encountered.
                                  abort();
                                }
                                return value;
                              };
                        
                              // Internal: Updates a traversed object member.
                              var update = function(source, property, callback) {
                                var element = walk(source, property, callback);
                                if (element === undef) {
                                  delete source[property];
                                } else {
                                  source[property] = element;
                                }
                              };
                        
                              // Internal: Recursively traverses a parsed JSON object, invoking the
                              // &#x60;callback&#x60; function for each value. This is an implementation of the
                              // &#x60;Walk(holder, name)&#x60; operation defined in ES 5.1 section 15.12.2.
                              var walk = function (source, property, callback) {
                                var value = source[property], length;
                                if (typeof value == &quot;object&quot; &amp;&amp; value) {
                                  // &#x60;forEach&#x60; can&#x27;t be used to traverse an array in Opera &lt;= 8.54
                                  // because its &#x60;Object#hasOwnProperty&#x60; implementation returns &#x60;false&#x60;
                                  // for array indices (e.g., &#x60;![1, 2, 3].hasOwnProperty(&quot;0&quot;)&#x60;).
                                  if (getClass.call(value) == arrayClass) {
                                    for (length = value.length; length--;) {
                                      update(value, length, callback);
                                    }
                                  } else {
                                    forEach(value, function (property) {
                                      update(value, property, callback);
                                    });
                                  }
                                }
                                return callback.call(source, property, value);
                              };
                        
                              // Public: &#x60;JSON.parse&#x60;. See ES 5.1 section 15.12.2.
                              JSON3.parse = function (source, callback) {
                                var result, value;
                                Index = 0;
                                Source = &quot;&quot; + source;
                                result = get(lex());
                                // If a JSON string contains multiple tokens, it is invalid.
                                if (lex() != &quot;$&quot;) {
                                  abort();
                                }
                                // Reset the parser state.
                                Index = Source = null;
                                return callback &amp;&amp; getClass.call(callback) == functionClass ? walk((value = {}, value[&quot;&quot;] = result, value), &quot;&quot;, callback) : result;
                              };
                            }
                          }
                        
                          // Export for asynchronous module loaders.
                          if (isLoader) {
                            define(function () {
                              return JSON3;
                            });
                          }
                        }(this));
                        
                        },{}],44:[function(_dereq_,module,exports){
                        module.exports = toArray
                        
                        function toArray(list, index) {
                            var array = []
                        
                            index = index || 0
                        
                            for (var i = index || 0; i &lt; list.length; i++) {
                                array[i - index] = list[i]
                            }
                        
                            return array
                        }
                        
                        },{}]},{},[1])
                        (1)
                        });
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
